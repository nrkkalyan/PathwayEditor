<?xml version="1.0" encoding="UTF-8"?>
<y:content xmlns="http://www.w3.org/1999/xhtml" xmlns:y="http://www.yworks.com/demo">
  <y:package javaname="demo">
  <y:displayname>Demos</y:displayname>
  <y:description>
    <h1>yFiles Demo Programs</h1>

    <p>
      The yFiles distributions contain a variety of tutorial Java programs
      accompanied by their source code. These programs demonstrate how to 
      use essential features of the yFiles library.
    </p>

    <p>
      Not all of the listed demos may be part of your yFiles distribution type.
      <b>yFiles Complete</b> contains all demo programs, <b>yFiles Viewer</b>
      contains all demos except the layout demos, <b>yFiles Layout</b>
      contains the graph, the graph algorithm, and the viewer independent
      layout demos in demo/layout. <b>yFiles Basic</b> contains only 
      the basic graph and graph algorithm demos.
    </p>

    <h2>Running the Demos</h2>

    <h3>From Within an IDE</h3>

    <p>
      Set <tt>&lt;yFilesDir&gt;/src</tt> as your source directory. 
      Then add <tt>&lt;yFilesDir&gt;/lib/y.jar</tt> <b>and</b> the source folder 
      <tt>&lt;yFilesDir&gt;/src</tt> to your classpath. 
      Now you should be ready to compile and run all executable demo classes. 
    </p>

    <p>
      If your IDE supports executing targets from ANT build files, the simplest
      way to run one of the demo programs is by calling the appropriate target
      from the demo build script <a href="build.xml">build.xml</a> located
      in this directory. See below for more information on the available ANT
      targets.
    </p>

    <h3>With Ant</h3>

    <p>
      First make sure you have the <a href="http://ant.apache.org">build tool Ant</a> 
      installed on your system. 
      Now you can use the demo build script <a href="build.xml">build.xml</a> located 
      in this directory to launch each demo by specifying its simple class name 
      as a target. 
    </p>

    <p>
      <b>Note:</b> 
      As an alternative, you can also use the build script's <tt>run</tt> target 
      to launch the DemoBrowser application, an interactive "shell" that allows 
      convenient access to all demos. 
      It features execution of each demo, and also displays both its source code 
      and documentation. 
    </p>

    <h2>Tutorial Demos</h2>

    <h3>Basic Graph Demos</h3>

    <p>
      Tutorial programs that show how to use the graph data type and related classes
      from the yFiles base package <a href="../../doc/api/y/base/package-summary.html">y.base</a>
      are located in the folder <a href="base/README.html">demo/base</a>. 
    </p>

    <h3>Graph Algorithm Demos</h3>

    <p>
      The graph algorithm demos are located in the folder 
      <a href="algo/README.html">demo/algo</a>. These tutorial
      demos show how to use some of the included graph and network algorithms
      that are located in the yFiles package <a href="../../doc/api/y/algo/package-summary.html">y.algo</a>.
    </p>

    <h3>Graph Viewer Demos</h3>

    <p>
      Programs that demonstrate how to use the yFiles graph viewer components in 
      an application are located in the folder <a href="view/README.html">demo/view</a>.
      <br/>
      Further aspects related to the viewer components and the visual representation of 
      graphs and their elements are demonstrated in several subpackages: 
    </p>
    <ul>
      <li>
        rendering in <a href="view/rendering/README.html">demo/view/rendering</a>
      </li>
      <li>
        node realizer and edge realizer customization in 
        <a href="view/realizer/README.html">demo/view/realizer</a> (and also in 
        <a href="view/advanced/README.html">demo/view/advanced</a> -- see below) 
      </li>
      <li>
        user interaction in 
        <a href="view/viewmode/README.html">demo/view/viewmode</a>
      </li>
    </ul>
    <p>
      The following subpackages present additional topics: 
    </p>
    <ul>
      <li>
        an extensive demo application that presents an organization chart in a visually 
        rich manner in <a href="view/orgchart/README.html">demo/view/orgchart</a>
      </li>
      <li>
        a demo application that presents a flowchart editor in <a href="view/flowchart/README.html">demo/view/flowchart</a>
      </li>
      <li>
        application-related functionality (undo/redo, print preview, etc.) in 
        <a href="view/application/README.html">demo/view/application</a>
      </li>
      <li>
        deploying yFiles viewer functionality as an applet inside web browsers in 
        <a href="view/applet/README.html">demo/view/applet</a>
      </li>
      <li>
        special node realizer features and how to support them with file I/O in 
        <a href="view/advanced/README.html">demo/view/advanced</a>
      </li>
    </ul>

    <h3>Graph Animation Demos</h3>

    <p>
      Programs that demonstrate how to add animated effects to graphs and views
      can be found in <a href="view/anim/README.html">demo/view/anim</a>.
    </p>

    <h3>Graph Hierarchy Demos</h3>
    <p>
      Sample applications that show how to use the nested graph hierarchy features 
      of yFiles are located in <a href="view/hierarchy/README.html">demo/view/hierarchy</a>.
    </p>

    <h3>Graph Layout Demos</h3>

    <p>
      Programs that demonstrate how to use the API of the diverse yFiles graph layout 
      algorithms can be found in the folder <a href="layout/README.html">demo/layout</a> 
      and its sub-folders. 
      Folder <a href="layout/withoutview/README.html">demo/layout/withoutview</a> contains
      demos that show how to use the layout and labeling
      functionality for various algorithms when the yFiles Viewer distribution is not present.              		      
    </p>

    <h3>Graph I/O Demos</h3>

    <p>
      Programs that show how to read and write graphs from and to different formats
      are located in <a href="io/README.html">demo/io</a>. This folder also 
      includes an example on how to customize and extend existing graph formats 
      to personal needs.
      <br/>
      The demos in <a href="io/graphml/README.html">demo/io/graphml</a> show how
      to use and how to customize the GraphML I/O functionality.
    </p>

    <h3>GUI Utility Demo</h3>

    <p>
      An example program that depicts the functionality of the yFiles 
      <a href="../../doc/api/y/option/package-summary.html">y.option</a>
      package of the yFiles Viewer distribution
      can be found in <a href="option/README.html">demo/option</a>.
    </p>

    <h2>yEd Lite Graph Editor Application</h2>

    <p>
      yEd Lite is a powerful multi-purpose
      graph editor. It exhibits most of the features available in
      the library. This source code demo is available as a separate download through our
      software download center.
    </p>


    <h2>yFiles Obfuscation Demo</h2>

    <p>
      <a href="obfuscation/README.html">This demo</a> shows how to obfuscate the yFiles 
      classes before they can be deployed as a part of an applet or application.
      In this demo the obfuscation process will be  performed by the Ant-based obfuscator 
      yGuard (<a href="http://www.yworks.com/products/yguard">yGuard home page</a>). 
    </p>
  </y:description>

<y:package javaname="demo.io">
  <y:displayname>Graph I/O</y:displayname>
    <y:displaypriority>50</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial I/O Demos</h1>
    <p>
    The following demos show how to use, customize, and extend
    the graph input and output facilities provided by yFiles.
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="graphml/README.html">demo.io.graphml</a>
        </td>
        <td>
          Conatins demos that focus on how to use, customize, and extend
          the GraphML graph interchange format input and output facilities
          provided by yFiles.
        </td>
      </tr>
    </table>
  </y:description>


  <y:demo javaname="demo.io.GraphFormatConverter" source="GraphFormatConverter.java" executable="false">
    <y:displayname>GraphFormatConverter</y:displayname>
    <y:description>
This class implements a command line driven graph format converter. 
Possible input formats are GraphML, ZIPGraphML, GML, or YGF. Output formats are 
GraphML, ZIPGraphML, GML, YGF, GIF, and JPG. 
Additionally, it is possible to write to the formats PDF, EMF, SWF, EPS, SVG, and 
SVGZ in case the corresponding yFiles extension packages ySVG and yExport are installed. 
The size of some output formats can be specified.
    </y:description>
  <y:keywords>
<y:keyword>converter</y:keyword>
<y:keyword>YGF</y:keyword>
<y:keyword>GML</y:keyword>
<y:keyword>ySVG</y:keyword>
<y:keyword>SVG</y:keyword>
<y:keyword>SVGZ</y:keyword>
<y:keyword>GraphML</y:keyword>
<y:keyword>Zip</y:keyword>
<y:keyword>GIF</y:keyword>
<y:keyword>JPG</y:keyword>
<y:keyword>yExport</y:keyword>
<y:keyword>EMF</y:keyword>
<y:keyword>SWF</y:keyword>
<y:keyword>PDF</y:keyword>
<y:keyword>EPS</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.io.ImageMapDemo" source="ImageMapDemo.java" browser="displayOnly">
    <y:displayname>ImageMapDemo</y:displayname>
    <y:description>This class shows how to generate an image and a hyperlinked 
HTML image map of a graph.
</y:description>
  <y:keywords>
<y:keyword>ImageMapOutputHandler</y:keyword>
<y:keyword>HTML</y:keyword>
<y:keyword>image</y:keyword>
<y:keyword>map</y:keyword>
<y:keyword>hyperlink</y:keyword>
<y:keyword>static</y:keyword>
<y:keyword>image</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.io.TiledImageDemo" source="TiledImageDemo.java" browser="displayOnly">
    <y:displayname>TiledImageDemo</y:displayname>
    <y:description>
This class shows how to export a diagram to multiple image tiles. 
Also, this demo shows how to add a title to the exported diagram.
</y:description>
  <y:keywords>
<y:keyword>TiledImageOutputHandler</y:keyword>
<y:keyword>image</y:keyword>
<y:keyword>tiling</y:keyword>
<y:keyword>tile</y:keyword>
<y:keyword>title</y:keyword>
<y:keyword>header</y:keyword>
<y:keyword>HTML</y:keyword>
<y:keyword>Drawable</y:keyword>
<y:keyword>header</y:keyword>
</y:keywords>
</y:demo>
<y:package javaname="demo.io.graphml">
  <y:displayname>GraphML</y:displayname>
  <y:description>
    <h1>GraphML I/O Demos</h1>
    <p>
      The following demos show how to use, customize, and extend
      the GraphML input and output facilities provided by yFiles.
    </p>
  </y:description>
  <y:demo javaname="demo.io.graphml.GraphMLDemo" source="GraphMLDemo.java">
    <y:displayname>GraphMLDemo</y:displayname>
    <y:description>Demonstrates basic usage of GraphMLIOHandler to load and save in the GraphML file format.
    </y:description>
    <y:keywords>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.GenericNodeRealizerDemo" source="GenericNodeRealizerDemo.java">
    <y:displayname>GenericNodeRealizerSerializationDemo</y:displayname>
    <y:description>Demonstrates how to create customized node realizers of type GenericNodeRealizer,
      how to add user data and how to read and write these customized types in GraphML format.
    </y:description>
    <y:keywords>
      <y:keyword>GenericNodeRealizer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizerSerializerDemo" source="CustomNodeRealizerSerializerDemo.java">
    <y:displayname>CustomNodeRealizerSerializerDemo</y:displayname>
    <y:description>
      A simple customization of the basic GraphMLDemo that uses objects of type
      CustomNodeRealizer as the graph's default node realizer.
      To enable encoding and parsing of this node realizer type a specific serializer
      implementation is registered with the GraphMLIOHandler.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>NodeRealizerSerializer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizer" source="CustomNodeRealizer.java" executable="false">
    <y:displayname>CustomNodeRealizer</y:displayname>
    <y:description>Custom NodeRealizer for use with CustomNodeRealizerSerializerDemo.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizerSerializer" source="CustomNodeRealizerSerializerDemo.java" executable="false">
    <y:displayname>CustomNodeRealizerSerializer</y:displayname>
    <y:description>Custom NodeRealizerSerializer that handles GraphML reading and writing of CustomNodeRealizer.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>NodeRealizerSerializer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.SimpleAttributesDemo" source="SimpleAttributesDemo.java">
    <y:displayname>SimpleAttributesDemo</y:displayname>
    <y:description>Demonstrates how to configure GraphMLIOHandler to be able to handle extra
      node and edge and of simple type. Additional data for a node or an edge can be edited by
      right-clicking on the corresponding element.
    </y:description>
    <y:keywords>
      <y:keyword>attributes</y:keyword>
      <y:keyword>simple</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.DynamicAttributesDemo" source="DynamicAttributesDemo.java">
    <y:displayname>DynamicAttributesDemo</y:displayname>
    <y:summary>Demonstrates how to configure GraphMLIOHandler to be able to handle attributes dynamically.
    </y:summary>
    <y:description>Demonstrates how to configure GraphMLIOHandler to be able to handle attributes dynamically. Input handlers
      for unhandled content are created automatically and the data is saved as DocumentFragments. The data can be serialized
      fully dynamically later on.
      <br/>
      Things to try:
      <ul>
        <li>Load an arbitrary graph that contains custom graphml attributes. Two sample graphs are already provided. Note
          how the text in the lower pane shows what becomes of the data during a load/save round-trip (the demo does not just display the
          text content of the original graphml file).
        </li>
        <li>
          Edit/delete/introduce custom attribute data in the graphml text pane and apply the changes to the graph. This will
          trigger a load/save round-trip.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>attributes</y:keyword>
      <y:keyword>dynamic</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.PostprocessorDemo" source="PostprocessorDemo.java">
    <y:displayname>PostprocessorDemo</y:displayname>
    <y:description>Demonstrates postprocessing actions that can be specified
      within a GraphML file. These actions allow to process the parsed graph structure
      before it gets returned by the GraphML parser.
    </y:description>
    <y:keywords>
      <y:keyword>YModule</y:keyword>
      <y:keyword>Postprocessor</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.XmlXslDemo" source="XmlXslDemo.java">
    <y:displayname>XmlXslDemo</y:displayname>
    <y:summary>
      Demonstrates how to use class XmlXslIOHandler to read XML content with the help of additional
      style sheets.
    </y:summary>
    <y:description>
      In order to read arbitrary XML content, an additional stylesheet is required that transforms the XML
      into valid GraphML. The demo already provides some stylesheets for Ant build scripts, OWL data and representation
      of the XML tree structure. The <code>sample files</code> combo box contains some predefined combinations.
      <br/>
      Note that the graphml pane is not editable for this demo.
    </y:description>
    <y:keywords>
      <y:keyword>YModule</y:keyword>
      <y:keyword>Postprocessor</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
    </y:package>
    <y:package javaname="demo.obfuscation">
  <y:displayname>Deploying yFiles</y:displayname>
  <y:displaypriority>-100</y:displaypriority>
  <y:description>
    <h1>yFiles Obfuscation Demo</h1>

    <p>
      This demo shows how to obfuscate the yFiles classes before they can be
      deployed as a part of an applet or application. Obfuscation changes 
      class, field, and method names in a consistent but nonsensical way that does
      not change the functionality of the software but makes decompiled Java code
      harder to read and publicly available API description of the original code 
      inapplicable to the obfuscated code.
    </p>

    <p>
      In this demo the obfuscation process will be performed by the Ant-based obfuscator yGuard. 
      In order to run yGuard it is required to have the freely available
      deployment tool <a href="http://ant.apache.org">Ant</a> installed on your system.
    </p>

    <p>
      The sample application used in this obfuscation demo is <a href="../view/hierarchy/README.html">
      demo.view.hierarchy.HierarchyDemo</a>.
    </p>

    <p>
      This demo contains the following files:
    </p>
    <table>
      <tr>
        <td>
              <a href="build.xml">build.xml</a>
            </td>
        <td>The Ant build script used to obfuscate the application.</td>
      </tr>
      <tr>
        <td>
              <a href="yguard/README.html">yGuard</a>
            </td>
        <td>The yGuard obfuscation task. The newest yGuard version can be freely obtained from
          the <a href="http://www.yworks.com/products/yguard">yGuard home page</a>.</td>
      </tr>
    </table>

    <h2>Running the Demo</h2>
    <p>
      Open a console window and change to this directory.
      Then enter "<tt>ant run</tt>". This will launch the obfuscated application.
      Before the application will be run it first will be compiled, jarred, 
      and obfuscated.
    </p>
    <p>
      Enter "<tt>ant show</tt>" to open up a small browser that shows the name mapping
      performed by the obfuscator.
    </p>
  </y:description>
</y:package>
    <y:package javaname="demo.base">
  <y:displayname>Graph Structure Demos</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Base Demos</h1>

    <p>The following tutorial base demos are in this package:</p>
  </y:description>

  <y:demo javaname="demo.base.ListDemo" source="ListDemo.java">
    <y:displayname>ListDemo</y:displayname>
    <y:description>
      Demonstrates how to use the yFiles linked list data type y.base.YList.
    </y:description>
    <y:keywords>
      <y:keyword>YCursor</y:keyword>
      <y:keyword>YList</y:keyword>
      <y:keyword>linked</y:keyword>
      <y:keyword>list</y:keyword>
      <y:keyword>cursor</y:keyword>
      <y:keyword>iteration</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.GraphDemo" source="GraphDemo.java">
    <y:displayname>GraphDemo</y:displayname>
    <y:description>
      Demonstrates how to use the yFiles directed graph data type y.base.Graph.
    </y:description>
    <y:keywords>
      <y:keyword>Graph</y:keyword>
      <y:keyword>directed</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
      <y:keyword>NodeMap</y:keyword>
      <y:keyword>EdgeMap</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.NodeMapTest" source="NodeMapTest.java">
    <y:displayname>NodeMapTest</y:displayname>
    <y:description>
      Demonstrates how to use node maps. The demo compares the performance of different 
      mechanisms to bind extra data to the nodes of a graph.
    </y:description>
    <y:keywords>
      <y:keyword>NodeMap</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
      <y:keyword>HashMap</y:keyword>
      <y:keyword>performance</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.ExtendedGraph" source="ExtendedGraph.java">
    <y:displayname>ExtendedGraph</y:displayname>
    <y:description>
      This class represents an extended Graph object whose nodes
      and edges carry additional data.
    </y:description>
    <y:keywords>
      <y:keyword>graph</y:keyword>
      <y:keyword>extending</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.RandomGraphGenerator" source="RandomGraphGenerator.java">
    <y:displayname>RandomGraphGenerator</y:displayname>
    <y:description>
      Implementation of a random graph generator. The size of the graph and other options
      may be specified. These options influence the properties of the created graph.
    </y:description>
    <y:keywords>
      <y:keyword>Graph</y:keyword>
      <y:keyword>random</y:keyword>
      <y:keyword>generate</y:keyword>
      <y:keyword>generation</y:keyword>
      <y:keyword>density</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
    <y:package javaname="demo.algo">
  <y:displayname>Graph Analysis Algorithms</y:displayname>
  <y:description>
    <h1>yFiles Tutorial Graph Algorithm Demos</h1>

    <p>
      The following graph algorithmic demos are in this package:
    </p>
  </y:description>

  <y:demo javaname="demo.algo.CyclesTest" source="CyclesTest.java">
    <y:displayname>CyclesTest</y:displayname>
    <y:description>
      
      
    Tests consistency and performance of two different cycle detection mechanisms
          provided by yFiles.</y:description>
  <y:keywords>
<y:keyword>Cycles</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>cycle</y:keyword>
<y:keyword>detection</y:keyword>
<y:keyword>performance</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.GraphConnectivityTest" source="GraphConnectivityTest.java">
    <y:displayname>GraphConnectivityTest</y:displayname>
    <y:description>
      
      
    Compares the performance and results of some graph connectivity algorithms available
          in yFiles.</y:description>
  <y:keywords>
<y:keyword>GraphConnectivity</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>connected</y:keyword>
<y:keyword>biconnected</y:keyword>
<y:keyword>connection</y:keyword>
<y:keyword>component</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.SpanningTreeTest" source="SpanningTreeTest.java">
    <y:displayname>SpanningTreeTest</y:displayname>
    <y:description>
      
      
    Compares the performance of minimum spanning tree algorithms available in yFiles.</y:description>
  <y:keywords>
<y:keyword>SpanningTrees</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>spanning</y:keyword>
<y:keyword>tree</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>Prim</y:keyword>
<y:keyword>Kruskal</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.ShortestPathTest" source="ShortestPathTest.java">
    <y:displayname>ShortestPathTest</y:displayname>
    <y:description>
      
      
    Compares the performance and results of some shortest path
          algorithms available in yFiles.</y:description>
  <y:keywords>
<y:keyword>ShortestPaths</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>shortest</y:keyword>
<y:keyword>path</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>Dijkstra</y:keyword>
<y:keyword>Bellman</y:keyword>
<y:keyword>Ford</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.ShortestPathDemo" source="ShortestPathDemo.java">
    <y:displayname>ShortestPathDemo</y:displayname>
    <y:description>
      
      
    Demonstrates how to use a Shortest Path Algorithm.</y:description>
  <y:keywords>
<y:keyword>ShortestPaths</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>shortest</y:keyword>
<y:keyword>path</y:keyword>
<y:keyword>weight</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.TopologicalTest" source="TopologicalTest.java">
    <y:displayname>TopologicalTest</y:displayname>
    <y:description>
      
      
    Compares different methods that calculate a topological
          node ordering on the nodes of an acyclic graph.</y:description>
  <y:keywords>
<y:keyword>NodeOrders</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>topological</y:keyword>
<y:keyword>DFS</y:keyword>
<y:keyword>completion</y:keyword>
<y:keyword>node</y:keyword>
<y:keyword>ordering</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.TopologicalSortDemo" source="TopologicalSortDemo.java">
    <y:displayname>TopologicalSortDemo</y:displayname>
    <y:description>
      
      
    Demonstrates how to implement a topological sort algorithm
          by using the generic depth-first search class y.algo.Dfs.</y:description>
  <y:keywords>
<y:keyword>Dfs</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>topological</y:keyword>
<y:keyword>sorting</y:keyword>
<y:keyword>depth</y:keyword>
</y:keywords>
</y:demo>

</y:package>
    <y:package javaname="demo.layout">
  <y:displayname>Automatic Layout</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial View Demos for Automatic Layout</h1>

    <p>
      This package and all of its subpackages provide tutorial demos that center around 
      automatic layout, routing and labeling features for diagrams.
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="hierarchic/README.html">demo.layout.hierarchic</a>
        </td>
        <td>Showcases diverse aspects and variants of hierarchical layout.</td>
      </tr>

      <tr>
        <td>
          <a href="organic/README.html">demo.layout.organic</a>
        </td>
        <td>Showcases diverse aspects and variants of organic layout.</td>
      </tr>

      <tr>
        <td>
          <a href="orthogonal/README.html">demo.layout.orthogonal</a>
        </td>
        <td>Showcases diverse aspects and variants of orthogonal layout.</td>
      </tr>

      <tr>
        <td>
          <a href="tree/README.html">demo.layout.tree</a>
        </td>
        <td>Showcases diverse aspects and variants of tree layout.</td>
      </tr>

      <tr>
        <td>
          <a href="labeling/README.html">demo.layout.labeling</a>
        </td>
        <td>Showcases diverse aspects and variants of automatic labeling.</td>
      </tr>

      <tr>
        <td>
          <a href="router/README.html">demo.layout.router</a>
        </td>
        <td>Showcases diverse aspects of automatic edge routing.</td>
      </tr>

      <tr>
        <td>
          <a href="genealogy/README.html">demo.layout.genealogy</a>
        </td>
        <td>Showcases various aspects of the yFiles layout facilities for
            genealogical data.</td>
      </tr>

      <tr>
        <td>
          <a href="partial/README.html">demo.layout.partial</a>
        </td>
        <td>Showcases diverse aspects and variants of partial layout.</td>
      </tr>

      <tr>
        <td>
          <a href="mixed/README.html">demo.layout.mixed</a>
        </td>
        <td>Showcases how to produce mixed layouts for grouped graphs using
            recursive group layout.</td>
      </tr>


      <tr>
        <td>
          <a href="module/README.html">demo.layout.module</a>
          </td>
        <td>Showcases how to use modules for interactive layout configuration. Also contains the complete source
        code of all layout modules that are part of yFiles.</td>
      </tr>

      <tr>
        <td>
          <a href="withoutview/README.html">demo.layout.withoutview</a>
          </td>
        <td>Showcases how to use the yFiles layout algorithms when the yFiles Viewer distribution is not present.
        </td>
      </tr>
      
    </table>
  </y:description>

  <y:demo javaname="demo.layout.LayoutDemo" source="LayoutDemo.java">
    <y:displayname>LayoutDemo</y:displayname>
    <y:description>Demonstrates how automatic layout and labeling algorithms can
    be applied to a graph that is displayed within a viewer component.
    Also shows how to apply an animated morphing effect between an existing layout
    and a newly created one.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>labeling</y:keyword>
      <y:keyword>automatic</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>morphing</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.Graph2DLayoutExecutorDemo" source="Graph2DLayoutExecutorDemo.java">
    <y:displayname>Graph2DLayoutExecutorDemo</y:displayname>
    <y:description>Demonstrates how Graph2DLayoutExecutor can be used to apply automatic layout
    to a graph that is displayed within a viewer component.
    The demo shows different ways of executing the layout asynchronously and synchronously.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>automatic</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>morphing</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>Thread</y:keyword>
      <y:keyword>threading</y:keyword>
      <y:keyword>blocking</y:keyword>
      <y:keyword>non-blocking</y:keyword>
      <y:keyword>asynchronous</y:keyword>
      <y:keyword>synchronous</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
    </y:keywords>
  </y:demo>

<y:package javaname="demo.layout.hierarchic">
  <y:displayname>Hierarchic</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Demos for Hierarchical Layout</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles hierarchical layout facilities.
    </p>
  </y:description>

  <y:demo javaname="demo.layout.hierarchic.IncrementalHierarchicLayouterDemo" source="IncrementalHierarchicLayouterDemo.java">
    <y:displayname>IncrementalHierarchicLayouterDemo</y:displayname>
    <y:summary>
      This demo shows how to use IncrementalHierarchicLayouter together
      with sophisticated customized view modes.
    </y:summary>
    <y:description>
      This demo shows how to use IncrementalHierarchicLayouter together
      with sophisticated customized view modes. The application will automatically perform
      a new layout whenever the user makes changes to the graph. The layout does not change
      the layer assignment of the nodes. Moreover, the sequence of nodes within each layer
      is preserved.
      <br/>
      The incremental layout aligns the centers of the nodes within a layer. Thus moving a
      node up or down a little bit such that its layer assignment does not change is normally
      immediately reverted by the following incremental layout. Similarly, moving a node
      a little bit to the left or right such that the sequence within its layer does not change
      also gets reverted by the following incremental layout.
      <p>
        Things to try:
      </p>
      <ul>
        <li>
          Create new nodes. The mouse location is used to determine the layer for the new node.
          Nodes created far away from the existing nodes are added to a new bottom layer.
        </li>
        <li>
          Move existing nodes. This is treated like creating new nodes. Additionally the target
          layer for the moved node is visually indicated.
        </li>
        <li>
          Create new edges.
        </li>
        <li>
          Move the first/last bend of an edge. This creates a port constraint (PC) which is
          visually indicated.
        </li>
        <li>
          Select a node and choose "Optimize Node". This triggers a layout which tries
          to improve the layout by ignoring the current layer assignment and sequence
          information for the selected node.
        </li>
        <li>
          The context menu for a set of selected nodes provides actions for fixing the layer
          or sequence coordinates of the selected nodes. Fixing the layer coordinates of at least
          two nodes within a layer means that they can be moved such that their centers are at
          different y coordinates and that the next incremental layout will preserve the difference
          of the y coordinates. Similarly, fixing the sequence coordinates of at least two nodes
          within a layer allows to control their distances in the direction of the x axis. Fixing
          the coordinates means fixing layer coordinates as well as sequence coordinates.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>automatic</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SwimlaneGroupDemo" source="SwimlaneGroupDemo.java">
    <y:displayname>SwimlaneGroupDemo</y:displayname>
    <y:summary>
      This demo shows the effect of combining
      <code>IncrementalHierarchicLayouter</code>'s support for grouping and
      swim lanes.
    </y:summary>
    <y:description>
      <p>
        This demo shows the effect of combining
        <code>IncrementalHierarchicLayouter</code>'s support for grouping and
        swim lanes.
      </p>
      <p>
        <b>Things to try:</b>
      </p>
      <ul>
        <li>
          Drag a node or set of nodes into another swim lane.
          This will automatically trigger an incremental layout calculation.
        </li>
        <li>
          Create a new node. It will be assigned to either a new swim lane if
          created to the left or right of the existing lanes or to the lane in
          which the node's center lies.
          This will automatically trigger an incremental layout calculation.
        </li>
        <li>
          Open/close folder/group nodes. Upon closing a group node, the resulting
          folder node will be assigned to the minimum swim lane of the group's
          child nodes.
          This will automatically trigger an incremental layout calculation.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>swimlane</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>expand</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.IncrementalHierarchicGroupDemo" source="IncrementalHierarchicGroupDemo.java">
    <y:displayname>IncrementalHierarchicGroupDemo</y:displayname>
    <y:description>
      This demo shows how IncrementalHierarchicLayouter can be used to fully or incrementally
      layout hierarchically nested graphs. The demo supports automatic relayout after expanding folder nodes,
      collapsing group nodes. Furthermore it provides toolbar buttons that
      trigger full layout and incremental relayout. A settings dialog for group layout options is provided as well.
      In incremental layout mode all selected elements are added incrementally to the existing layout.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>expand</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>node</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.LayerConstraintsDemo" source="LayerConstraintsDemo.java">
    <y:displayname>LayerConstraintsDemo</y:displayname>
    <y:summary>
      Demo that shows how to apply layer constraints when calculating hierarchical layouts.
    </y:summary>
    <y:description>
      Demo that shows how to apply layer constraints when calculating hierarchical layouts.
      <p>With the buttons on the left side of the GUI,
        various constraints can be set on the currently selected nodes (either absolute
        top/bottom level or relative layering constraints). The "Top-most"/"Bottom-most"
        buttons set absolute layering constraints, whereas the other buttons assign
        relative layering constraints. The top button ("Remove constraints") clears all
        constraints from the currently selected nodes.
      </p>
      <p>
        Additionally, a DataProvider is registered under the key
        <code>ConstraintIncrementalLayerer.EDGE_WEIGHTS_DPKEY</code>, and if a numeric
        edge label is set, that label gets set as
        value for that DataProvider.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>absolute</y:keyword>
      <y:keyword>relative</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>layer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.PortCandidateDemo" source="PortCandidateDemo.java">
    <y:displayname>PortCandidateDemo</y:displayname>
    <y:description>
      This demo shows how port candidate sets can be used with the incremental hierarchic layouter
      to control from what side edges connect to certain node types in the automatic layout process.
      <br/>
      Usage: The template nodes in the list to the left have different port candidate sets. Try changing
      the graph using the templates and note the effect for a new layout.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>port candidate</y:keyword>
      <y:keyword>portcandidateset</y:keyword>
      <y:keyword>chart</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SequenceConstraintsDemo" source="SequenceConstraintsDemo.java">
    <y:displayname>SequenceConstraintsDemo</y:displayname>
    <y:description>
      Demonstrates how to apply sequence constraints when calculating hierarchical
      layouts. For hierarchical layouts, a sequence is the in-layer order of nodes,
      e.g. with layout direction from top to bottom, a sequence is the left to
      right order of nodes.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>absolute</y:keyword>
      <y:keyword>relative</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>sequence</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>order</y:keyword>
      <y:keyword>head</y:keyword>
      <y:keyword>tail</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SimpleSwimlaneLayouterDemo" source="SimpleSwimlaneLayouterDemo.java">
    <y:displayname>SimpleSwimlaneLayouterDemo</y:displayname>
    <y:summary>
      Demonstrates the swim lane feature of the IncrementalHierarchicLayouter.
    </y:summary>
    <y:description>
      <p>
        This simple demo shows how to use the swim lane feature of the
        IncrementalHierarchicLayouter.
      </p>
      <p>
        It can either calculate a new layout or calculate a new layout given the current
        sketch or incrementally layout selected nodes to an already existing graph whose
        layout is read from the current sketch.
      </p>
      <p>
        <b>Things to try:</b>
        <br/>
        Create a graph and assign nodes to layers by editing the label of the nodes.
        Nodes with the same layer will be placed into the same swim lane. Swim lanes
        are sorted from left to right in ascending label order.
        <br/>
        Use the
        <b>Layout</b>
        button to lay it out from scratch.
        Modify the graph (move nodes and or bends), deselect all elements and
        choose
        <b>Layout from Sketch</b>
        to recalculate the layout using the given sketch
        Add some nodes and connect them to the graph, select the newly added nodes
        and choose
        <b>Layout Incrementally</b>
        to incrementally "add" the selected
        elements optimally into the existing graph.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>swimlane</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SimpleIncrementalHierarchicLayouterDemo" source="SimpleIncrementalHierarchicLayouterDemo.java">
    <y:displayname>SimpleIncrementalHierarchicLayouterDemo</y:displayname>
    <y:summary>
      This simple demo shows how to use the IncrementalHierarchicLayouter
      to either calculate a new layout or calculate a new layout given the current
      sketch or incrementally layout selected nodes to an already existing graph whose
      layout is read from the current sketch.
    </y:summary>
    <y:description>
      This simple demo shows how to use the IncrementalHierarchicLayouter
      to either calculate a new layout or calculate a new layout given the current
      sketch or incrementally layout selected nodes to an already existing graph whose
      layout is read from the current sketch.
      <br/>
      <br/>
      Things to try:
      <br/>
      Create a graph and use the
      <b>Layout</b>
      button to lay it out from scratch.
      Modify the graph (move nodes and or bends), deselect all elements and
      choose
      <b>Layout From Sketch</b>
      to recalculate the layout using the given sketch
      Add some nodes and connect them to the graph, select the newly added nodes
      and choose
      <b>Layout Incrementally</b>
      to incrementally "add" the selected
      elements optimally into the existing graph.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.HierarchicLayouterDemo" source="HierarchicLayouterDemo.java">
    <y:displayname>HierarchicLayouterDemo</y:displayname>
    <y:summary>
      Demonstrates various aspects of the HierarchicLayouter.
    </y:summary>
    <y:description>
      This Demo shows how HierarchicLayouter can handle port constraints,
      how it can take edge labels into consideration when laying out
      a graph and how to specify groups of nodes, which will be placed next to
      each other on each layer.
      <br/>
      <br/>
      <b>Usage:</b>
      <br/>
      After starting the demo create a graph manually in the graph editor
      pane. Now click on the "Layout" Button in the toolbar to
      start the hierarchic layouter.
      <br/>
      Additional port constraints can be specified for HierarchicLayouter.
      A port constraint expresses on what side of a node the source and/or
      target point of an edge should connect. To add a port constraint to an edge
      first select the edge by clicking on it. Then choose the desired source and target
      port constraint for the selected edge with the radio button panel on the left of
      the graph pane. Selecting "South" from the "Source Port" choice for example
      means the edge selected edge should connect to the bottom side of the source node.
      Alternatively once can simply move or create the first or last bend of an edge.
      A visual clue will appear that determines the PortConstraint.
      <br/>
      A port constraint that is marked as "strong", means that the associated
      port coordinate given to the layouter will not be modified by the layouter.
      <br/>
      After the port constraints have been set up it is time to press the
      "layout" button again. Now the resulting layout is a hierarchic layout
      that obeys the additional port constraints.
      <br/>
      To activate the edge labeling feature check the box named "Label Edges" just below
      the port constraint selector pane.
      If this feature is turned on then on there will be edge labels visible that
      display the type of port constraint activated for the source and target port
      of each edge. Now by pressing the "Layout" button again the resulting layout
      will consider these edge labels as well. One can see that none of the labels
      overlap and that the size of the layout has increased.
      <br/>
      The toolbar button "Option..." allows to specify diverse layout parameters
      for the layouter. Not all of these options are important to this demo.
      Noteworthy options for this demo are "Edge Routing: Orthogonal" and in tab
      "Node Rank" the ranking policy "From Sketch".
      <br/>
      "Edge Routing: Orthogonal" has the effect of routing all edges orthogonally,
      i.e. by using only horizontal and vertical line segments.
      <br/>
      "Ranking Policy: From Sketch" has the effect that the layer partitions will be
      established by the given drawing heuristically (looking at the y-coordinates
      of the nodes). By this option it is possible to put nodes in the same layer that
      are connected by an edge.
      <br/>
      <br/>
      Node Groups:
      By clicking on one of the colored buttons in the left bar, the currently selected
      nodes will be assigned to the corresponding group. This grouping will be
      indicated by the node color. When being layouted, nodes on the same layer
      having the same group (color) will be placed next to each other as a compound
      group.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>port</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>integrated</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>labeling</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.CriticalPathDemo" source="CriticalPathDemo.java">
    <y:displayname>CriticalPathDemo</y:displayname>
    <y:summary>
      Demonstrates IncrementalHierarchicLayouter's critical path feature.
      The algorithm will try to align the nodes of a critical path such
      that the interconnecting edges can be routed in a straight, vertical
      fashion.
    </y:summary>
    <y:description>
      <p>
        This demo presents the critical edge feature of the hierarchic layouter. The layouter tries to vertically align each node pair
        that is connected by an edge marked as "critical". This feature can be utilized to highlight different edge paths that are relevant for a user.
        The demo allows to manually mark/unmark critical edges by selecting some edges and, then, pressing button "Mark Selected Edges"/"Unmark Selected Edges".
        Critical edges are colored red, common edges are colored black. The current state of selected edges can be toggled by double-clicking.
        Pressing the "Apply Layout" button calculates a new layout of the current graph.
      <br/>
        Pressing button "Mark Longest Path" allows to automatically select all edges that belong to a longest path of the graph.
        If two nodes of the graph are marked as selected, pressing button "Mark Path Between Two Nodes" selects all edges
        of the shortest-path between this nodes.
      </p>
      <h3>Layout Settings</h3>
      <p>
        The demo allows to specify the following layout properties:
      </p>
      <dl>
        <dt>Minimal Layer Distance:</dt>
        <dd>Specifies the minimum distance between two adjacent layers.</dd>
        <dt>Minimal Node Distance:</dt>
        <dd>Specifies the minimum distance between two adjacent nodes.</dd>
        <dt>Use Orthogonal Edge Routes:</dt>
        <dd>Whether or not edges are routed orthogonally. If this option is disabled, edges are routed polyline.</dd>
        <dt>Enable Backloop Routing:</dt>
        <dd>Whether or not reverse edges are routed as backloops, i.e., such that they also leave their source node at the bottom
        and enter their target node at the top.</dd>
        <dt>Enable Edge Straightening:</dt>
        <dd>Whether or not an edge straightening optimization should be applied. This optimization tries to further reduce the number of bends.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.tree">
  <y:displayname>Tree</y:displayname>
  <y:displaypriority>60</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Demos for Tree Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles tree layout facilities.
    </p>
  </y:description>

  <y:demo javaname="demo.layout.tree.CollapsibleTreeDemo" source="CollapsibleTreeDemo.java">
    <y:displayname>CollapsibleTreeDemo</y:displayname>
    <y:description>
      This demo shows how subtrees can be collapsed and expanded by simply
      clicking on their respective root nodes. 
      Several different layout algorithms can be chosen:
      <code>y.layout.tree.TreeLayouter</code>,
      <code>y.layout.tree.BalloonLayouter</code>,
      <code>y.layout.organic.SmartOrganicLayouter</code>, and
      <code>y.layout.hierarchic.IncrementalHierarchicLayouter</code>.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>expand</y:keyword>
      <y:keyword>subtree</y:keyword>
      <y:keyword>TreeLayouter</y:keyword>
      <y:keyword>BalloonLayouter</y:keyword>
      <y:keyword>OrganicLayouter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.TreeLayoutConfigurationDemo" source="TreeLayoutConfigurationDemo.java">
    <y:displayname>TreeLayoutConfigurationDemo</y:displayname>
    <y:description>
      This demo serves as a launcher for the tree layout styles offered by TreeLayoutConfiguration.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>configuration</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.DendrogramLayouterDemo" source="DendrogramLayouterDemo.java">
    <y:displayname>DendrogramLayouterDemo</y:displayname>
    <y:summary>
      This demo shows how to dynamically maintain a tree as a dendrogram.
    </y:summary>
    <y:description>
      <p>
      This demo shows how to dynamically maintain a tree as a dendrogram, i.e. all subtrees of a single
      local root align at their bottom border. It uses <code>GenericTreeLayouter</code>,
      <code>DendrogramPlacer</code> and <code>CreateChildEdgeMode</code>.
      </p>
      <p>
      <br>Usage:</br> Add new nodes by dragging an edge from the parent node of the new node. In this demo the
      create edge gesture does not need to be completed at a target node. It can end anywhere. The target
      node is created as a child node of the source node for the gesture. The target location of the gesture
      determines the relative position of the new child node among the children of its parent node. Adding
      a node, moving a set of selected nodes or changing their sizes triggers a new layout which restores
      the dendrogram style of the tree.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>dendrogram</y:keyword>
      <y:keyword>DendrogramPlacer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.IncrementalTreeLayouterDemo" source="IncrementalTreeLayouterDemo.java">
    <y:displayname>IncrementalTreeLayouterDemo</y:displayname>
    <y:summary>
      This demo shows how GenericTreeLayouter can handle port constraints and multiple
      different NodePlacer instances and implementations at the same time.
    </y:summary>
    <y:description>
      <p>
      This demo shows how GenericTreeLayouter can handle port constraints and multiple
      different NodePlacer instances and implementations at the same time.
      </p>
      <p>
      <b>Usage:</b> Use the panel on the left to change the layout settings such as port constraints
      or node placers for all nodes at a certain level of the tree simultaneously by pressing
      the "Apply" button. The panel in the lower left is a preview for the currently displayed
      settings. You can also change the settings for individual nodes by using their context
      menus.
      <br/>
      On another note, the demo also demonstrates how different ViewModes can be subclassed
      or replaced to achieve a completely different application feel.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.AssistantPlacerDemo" source="AssistantPlacerDemo.java">
    <y:displayname>AssistantPlacerDemo</y:displayname>
    <y:summary>
      This demo shows how to use <code>GenericTreeLayouter</code> in conjunction
      with <code>AssistantPlacer</code>.
    </y:summary>
    <y:description>
      This demo shows how to use <code>GenericTreeLayouter</code> in conjunction
      with <code>AssistantPlacer</code>.
      <br/>
      Usage: This demo offers its functionality via context menus. The actual selected
      nodes can be marked as assistants or "non-assistants," and the child node
      placer can be be set this way, too.
      <br/>
      AssistantPlacer is a special NodePlacer that uses two layout strategies.
      Depending on the boolean provided through the special DataProvider found at
      the key <code>AssistantPlacer#ASSISTANT_DPKEY</code>, the AssistantPlacer
      decides how to layout its children.
      <br/>
      If the boolean is set to true for a specific node, it is interpreted as "assistant."
      All assistants are placed using the <code>LeftRightPlacer.</code>
      <br/>
      The other children are placed below the assistants, using the child node
      placer of the AssistantPlacer. The child node placer can be set using the
      method <code>setChildNodePlacer</code>.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>assistant</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>chart</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>AssistantPlacer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.RotatableNodePlacersDemo" source="RotatableNodePlacersDemo.java">
    <y:displayname>RotatableNodePlacersDemo</y:displayname>
    <y:summary>
      This demo presents <code>GenericTreeLayouter</code> in conjunction
      with node placers that support subtree rotation.
    </y:summary>
    <y:description>
      This demo presents GenericTreeLayouter in conjunction with node placers that support
      subtree rotation. The NodePlacers, rotations and root alignments for the selected nodes may
      be changed using the panel on the left side.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>subtree</y:keyword>
      <y:keyword>rotate</y:keyword>
      <y:keyword>rotation</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.organic">
  <y:displayname>Organic</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Demos for Organic Layout</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles organic layout facilities.
    </p>
  </y:description>

  <y:demo javaname="demo.layout.organic.OrganicLayouterDemo" source="OrganicLayouterDemo.java">
    <y:displayname>OrganicLayouterDemo</y:displayname>
    <y:summary>
      Demonstrates different organic layout algorithms and
      how to specify individual preferred edge lengths
      for OrganicLayouter.
    </y:summary>
    <y:description>
      Demonstrates different organic layout algorithms and
      how to specify individual preferred edge lengths
      for OrganicLayouter.
      <br/>
      In this demo the edge lengths can be specified by right clicking
      on an edge or applying the current node distances using the button from the
      toolbar.
      <br/>
      Choose the item "Edit Preferred Edge Length" from the context menu to open up
      a label editor that allows for entering a value for the edge length in pixels.
      Note that the entered value must be numeric. Otherwise
      a default length will be chosen.
    </y:description>
    <y:keywords>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>OrganicLayouter</y:keyword>
      <y:keyword>preferred</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>length</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.AnimatedNavigationDemo" source="AnimatedNavigationDemo.java">
    <y:displayname>AnimatedNavigationDemo</y:displayname>
    <y:description>
      This is an extension of NavigationDemo.
      In this demos changing the visible subgraph is accompanied by animated
      fade in and fade out effects for appearing and disappearing nodes and edges.
    </y:description>
    <y:keywords>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>fade</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.NavigationDemo" source="NavigationDemo.java">
    <y:displayname>NavigationDemo</y:displayname>
    <y:description>
      Demonstrates how to interactively navigate through a large
      graph by showing only the surroundings of a focused node.
      In this demo the layout of the displayed subgraph is
      controlled by <code>InteractiveOrganicLayouter</code>
    </y:description>
    <y:keywords>
      <y:keyword>InteractiveOrganicLayouter</y:keyword>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>navigation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.InteractiveOrganicDemo" source="InteractiveOrganicDemo.java">
    <y:displayname>InteractiveOrganicDemo</y:displayname>
    <y:description>
      This demo shows the very basic usage of the InteractiveOrganicLayouter.
      The layouter is started within a thread and a swing timer is used to
      update the positions of the nodes.
    </y:description>
    <y:keywords>
      <y:keyword>InteractiveOrganicLayouter</y:keyword>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>thread</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.router">
  <y:displayname>Edge Routing</y:displayname>
  <y:displaypriority>80</y:displaypriority>
  <y:description>
<h1>yFiles Tutorial Demos for Edge Routing</h1>
<p>
This package contains tutorial source code demos that showcase
various aspects of the yFiles edge routing facilities.
</p>
</y:description>
  <y:demo javaname="demo.layout.router.EdgeRouterDemo" source="EdgeRouterDemo.java">
    <y:displayname>EdgeRouterDemo</y:displayname>
    <y:summary>
      Demonstrates yFiles' orthogonal edge routing capabilities.
    </y:summary>
    <y:description>
      A demo that shows some of the capabilities of the yFiles Orthogonal Edge Router implementations.
      <br/>
      Usage: Create nodes. Create edges crossing other nodes. The edges will be routed immediately.
      To reroute all edges use the toolbar button "Route Edges".
      <br/>
      The following aspects of using
      the edge routers are demonstrated.
      <ol>
        <li>How to use OrthogonalEdgeRouterModule or ChannelEdgeRouterModule as a convenient
          means to launch and configure the edge routers.
        </li>
        <li>How to modify the yFiles EditMode in order to trigger the orthogonal edge router
          whenever
          <ul>
            <li>new edges get created</li>
            <li>nodes get resized</li>
            <li>selected nodes will be moved</li>
          </ul>
        </li>
        <li>
          How to specify port constraints for the edge router. With the help of port constraints
          it is possible to tell the orthogonal edge router on which side of a node or on which
          exact coordinate a start or endpoint of an edge should connect to a node.
        </li>
      </ol>
    </y:description>
    <y:keywords>
<y:keyword>OrthogonalEdgeRouter</y:keyword>
<y:keyword>edge</y:keyword>
<y:keyword>routing</y:keyword>
<y:keyword>ChannelEdgeRouter</y:keyword>
</y:keywords>
</y:demo>
  <y:demo javaname="demo.layout.router.MazeRouterDemo" source="MazeRouterDemo.java">
    <y:displayname>MazeRouterDemo</y:displayname>
    <y:summary>
      Demonstrates yFiles' orthogonal edge routing capabilities through a maze.
    </y:summary>
    <y:description>
      Advanced edge routing demo. Demonstrates yFiles' orthogonal edge
      routing capabilities through a maze.
      <br/>
      Usage: Create nodes and edges. The edges will be routed immediately. To reroute
      all edges use the toolbar button "Route Edges".
      <br/>
      The following aspects of using the edge routers are demonstrated.
      <ol>
        <li>How to use OrthogonalEdgeRouterModule and ChannelEdgeRouterModules respectively as
          a convenient means to launch and
          configure the edge routers.
        </li>
        <li>How to modify the yFiles EditMode in order to trigger the
          orthogonal edge router whenever
          <ul>
            <li>new edges get created</li>
            <li>nodes get resized</li>
            <li>selected nodes will be moved</li>
          </ul>
        </li>
      </ol>
      Additionally this demo shows how uneditable background-layer graphs can be displayed
      inside the graph view.
      <br/>
    </y:description>
  <y:keywords>
<y:keyword>OrthogonalEdgeRouter</y:keyword>
<y:keyword>edge</y:keyword>
<y:keyword>routing</y:keyword>
<y:keyword>maze</y:keyword>
</y:keywords>
</y:demo>
<y:demo javaname="demo.layout.router.BusRouterDemo" source="BusRouterDemo.java">
  <y:displayname>BusRouterDemo</y:displayname>
  <y:summary>
    Demonstrates the orthogonal bus-style edge routing capabilities of yFiles.
  </y:summary>
  <y:description>
    <p>
      This demo shows the capabilities of the yFiles Bus Router and demonstrates specific <em>hub</em>
      nodes to ease the usage in an interactive environment.
    </p>
    <p>
      A bus can be used to display the connections in a complete subgraph, that is a group in which each node has an
      edge to every other node. To disburden users from entering all these edges manually, this application introduces
      a specific type of nodes, so-called<em>hubs</em>, which act as interconnection points of the bus. Each bus is
      composed of its interconnected hubs and all their adjacent edges. For clarity, the hubs and edges of the same bus
      are displayed in a common color.
    </p>

    <h3>Main aspects of this demo</h3>

    <ul>
      <li>
                <code>BusRouterModule</code> which is a convenient means to launch and configure the bus router. Available
        settings include minimum distances from obstacles and whether a grid is enabled or disabled.
      </li>
      <li>Routing of all buses and routing of selected buses only</li>
      <li>Multiple connections of a node to the same bus</li>
      <li>Fixed edges which calculates routes only for <i>free</i> connections.</li>
      <li>The Usage of hub nodes to ease the editing of buses.</li>
      <li>Provided methods to convert hubs into the representation expected by <code>BusRouter</code> and vice versa.
      </li>
    </ul>

    <h3>Usage</h3>

    <dl>
      <dt>Adding new nodes</dt>
      <dd>
        The palette in the side panel provides two node templates, the upper one for regular nodes and lower one for
        hubs. To create a node either drag its template from the side panel into the graph view or click at the desired
        location in the view. In the latter case, the new node's type is defined by the selected template.
      </dd>

      <dt>Adding new edges</dt>
      <dd>
        To create an edge, start dragging the mouse and keep the mouse button pressed while over a node. If an edge is
        connected to a hub, its color changes to reflect its affiliation to a bus. There is no restriction on the
        structure of a bus, however, the routing algorithm removes cycles and dead-end paths.
      </dd>

      <dt>Removing nodes and edges</dt>
      <dd>
        Selected nodes and edges can be removed using the <code>DELETE</code> key or the corresponding icon in the tool
        bar.
      </dd>

      <dt>Routing buses</dt>
      <dd>
        The routing algorithm and its properties are available in the tool bar. Use <code>Route All</code> to calculate
        a new routing for all buses and <code>Route Selected</code> to route each bus in which at least one edge, one
        hub or one adjacent regular node is selected. Unselected orthogonal edges of other buses are taken into account
        for calculating the best routes while unselected non-orthogonal edges are completely ignored by the algorithm.
      </dd>
    </dl>

    <h3>Settings</h3>

    <dl>
      <dt>Automatic routing</dt>
      <dd>
        Triggers an automatic routing for the connections of moved nodes, in which the remainders of the affected buses
        are kept fixed. New single-edge buses are routed automatically, too. Note that the routing algorithm will remove
        cycles and dead-end paths.
      </dd>

      <dt>Grid</dt>
      <dd>
        Affects both the editor and the routing algorithm. If enabled, a grid of the given spacing is shown in the
        view and the algorithm assigns positions on grid coordinates if possible.
      </dd>

      <dt>Orthogonal mode</dt>
      <dd>
        Activates the orthogonal edge creation mode which restricts edge paths of newly created edges to
        horizontal and vertical segments. Orthogonal edges are distinguishable by thicker lines.
      </dd>

      <dt>Snapping</dt>
      <dd>
        Specifies whether snap lines are activated.
      </dd>
    </dl>
  </y:description>
  <y:keywords>
    <y:keyword>BusRouter</y:keyword>
    <y:keyword>edge</y:keyword>
    <y:keyword>routing</y:keyword>
    <y:keyword>orthogonal</y:keyword>
    <y:keyword>bus</y:keyword>
  </y:keywords>
</y:demo>
</y:package>
      <y:package javaname="demo.layout.labeling">
   <y:displayname>Labeling</y:displayname>
   <y:displaypriority>40</y:displaypriority>
   <y:description>
 <h1>yFiles Tutorial Demos for Automatic Labeling</h1>
 <p>
 This package contains tutorial source code demos that showcase automatic node
 and edge labeling.
 </p>
 </y:description>
   <y:demo javaname="demo.layout.labeling.NodeLabelingDemo" source="NodeLabelingDemo.java">
     <y:displayname>NodeLabelingDemo</y:displayname>
     <y:summary>
         Demonstrates basic node labeling features.
     </y:summary>
       <y:description>
           <p>
               This demo shows how to configure node labels and the corresponding node label models as well as how to
               apply the generic node labeling algorithm.
           </p>

           <h3>Usage</h3>

           <dl>
             <dt>Adding a new City</dt>
             <dd>
               A new city (node) can be added by left-clicking on the corresponding map location.
             </dd>
             <dt>Editing a Label</dt>
             <dd>
               To change a label text, use <code>Edit Label</code> from the label's context menu.
               Labels can be moved by drag and drop to another valid position.
             </dd>

             <dt>Automatic Label Placement</dt>
             <dd>
               The generic labeling algorithm is applied automatically after changing any of the properties in the side
               bar. To manually apply the generic labeling algorithm click on <code>Place Labels</code> in the tool bar.
             </dd>
           </dl>

           <h3>Properties</h3>

           <dl>
               <dt>Label Model</dt>
               <dd>
                   The label model of the node labels. A label model defines the set of valid positions of
                   labels. Note: since the <code>Free</code> label model allows any position, it usually offers the best
                   results.
               </dd>

               <dt>Label Size</dt>
               <dd>
                   The font size of the text of the labels.
               </dd>
           </dl>
       </y:description>
       <y:keywords>
           <y:keyword>labeling</y:keyword>
           <y:keyword>automatic</y:keyword>
           <y:keyword>algorithm</y:keyword>
           <y:keyword>GreedyMISLabeling</y:keyword>
           <y:keyword>SALabeling</y:keyword>
           <y:keyword>label</y:keyword>
           <y:keyword>node label</y:keyword>
           <y:keyword>model</y:keyword>
       </y:keywords>
   </y:demo>
     <y:demo javaname="demo.layout.labeling.EdgeLabelingDemo" source="EdgeLabelingDemo.java">
         <y:displayname>EdgeLabelingDemo</y:displayname>
         <y:summary>
             Demonstrates basic edge labeling features.
         </y:summary>
       <y:description>
         <p>
           This demo shows how to configure edge labels and the corresponding edge label models as well as
           how to apply the generic edge labeling algorithm.
         </p>

         <h3>Usage</h3>

         <dl>
           <dt>Adding a new Label</dt>
           <dd>
             To add a new edge label right-click on an edge and choose item <code>Add Label</code>.
           </dd>

           <dt>Editing a Label</dt>
           <dd>
             To change a label text, use <code>Edit Label</code> from the label's context menu. Labels can be moved by
             drag and drop to another valid position.
           </dd>

           <dt>Automatic Label Placement</dt>
           <dd>
             The generic labeling algorithm is applied automatically after changing any of the properties in the side
             bar. To manually apply the generic labeling algorithm click on <code>Place Labels</code> in the tool bar.
           </dd>
         </dl>

         <h3>Properties</h3>

         <dl>
           <dt>Rotation Angle</dt>
           <dd>
             The rotation angle (in degrees) of the edge labels. If auto rotation is enabled, this angle is added to the
             angle calculated by auto rotation.
           </dd>

           <dt>Auto Flipping</dt>
           <dd>
             If enabled, automatically flips the presentation of a label when it is upside-down.
           </dd>

           <dt>Label Model</dt>
           <dd>
             The label model of the edge labels. A label model defines the set of valid positions of each label.
           </dd>

           <dt>Auto Rotation</dt>
           <dd>
             If enabled, labels are placed in parallel to their corresponding edge segment. The specified rotation angle
             is added to the angle calculated by this feature.
           </dd>

           <dt>Allow 90 Degree Deviation</dt>
           <dd>
             If enabled, allows additional positions which are rotated by 90 degrees with respect to the positions
             calculated by auto rotation.
           </dd>

           <dt>Edge To Label Distance</dt>
           <dd>
             Specifies the minimum distance between an edge label and the corresponding edge segment.
           </dd>
         </dl>

       </y:description>
       <y:keywords>
             <y:keyword>labeling</y:keyword>
             <y:keyword>automatic</y:keyword>
             <y:keyword>algorithm</y:keyword>
             <y:keyword>MISLabeling</y:keyword>
             <y:keyword>SALabeling</y:keyword>
             <y:keyword>label</y:keyword>
             <y:keyword>edge label</y:keyword>
             <y:keyword>model</y:keyword>
         </y:keywords>
     </y:demo>

 </y:package>
      <y:package javaname="demo.layout.mixed">
  <y:displayname>Mixed Layouts</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial for Mixed Layouts</h1>
    <p>
    The following tutorial shows how to produce mixed layouts for grouped graphs using the recursive group layouter.
    </p>
  </y:description>
  <y:demo javaname="demo.layout.mixed.MixedLayoutDemo" source="MixedLayoutDemo.java">
    <y:displayname>MixedLayoutDemo</y:displayname>
    <y:summary>
      This demo extends
      <code>GroupingDemo</code>
      to show how to use the recursive group layouter to apply different layouts to the contents of group nodes.
    </y:summary>
    <y:description>
       The demo shows how to apply the recursive group layouter to the following two use cases:
         <ul>
          <li>Table Layout: demonstrates how to realize a table node structure, i.e.,
       each group node in the drawing represents a table and the nodes within the groups the table rows. Edges are connected
       to specific rows. The rows are sorted according to their y-coordinate in the initial drawing.</li>
          <li>Three-Tier Layout: demonstrates how to use the recursive group layout to realize different layouts of elements assigned to different tiers.
       Each group node can be assigned to the left, right or middle tier (depending on the group node label).
       All group nodes labeled "left" are placed on the left side. Their content is drawn using a TreeLayouter with
       layout orientation left-to-right. Analogously, all group nodes labeled "right" are placed on the right side.
       Their content is drawn using a TreeLayouter with layout orientation right-to-left. Elements not assigned to "left" or
       "right" group nodes are always lay out in the middle using the IncrementalHierarchicLayouter with layout orientation left-to-right.
        Note that group nodes not labeled "left" or "right" are handled non-recursive.</li>
        </ul>
        In order to recalculate the layout press the "Auto-Layout Graph" button.
        If the "Use Sketch" option is enabled the IncrementalHierarchicLayouter uses the from sketch mode, i.e.,
        it uses the current drawing as sketch.         
    </y:description>
    <y:keywords>
        <y:keyword>HierarchyManager</y:keyword>
        <y:keyword>recursive</y:keyword>
        <y:keyword>group</y:keyword>
        <y:keyword>node</y:keyword>
        <y:keyword>nested</y:keyword>
        <y:keyword>grouping</y:keyword>
        <y:keyword>hierarchical</y:keyword>        
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.mixed.RecursiveLayoutDemo" source="RecursiveLayoutDemo.java">
    <y:displayname>RecursiveLayoutDemo</y:displayname>
    <y:summary>
      This demo extends
      <code>GroupingDemo</code>
      to show how to use the recursive group layouter.
    </y:summary>
    <y:description>
  The content of each group node is recursively laid out with the specified layouter, i.e., the layouter is applied to each group node separately.
  Note that the RecursiveGroupLayouter also supports to specify different layout algorithms for different group nodes, see MixedLayoutDemo.
  If the "Route Inter-Edges" option is enabled an edge router is used for routing the inter-edges (the green edges), i.e., edges which traverse the boundary of group nodes.
  Due to the recursive layout fashion the core layout often doesn't produce satisfiable edge routes for such edges. 
  In order to recalculate the layout press the "Auto-Layout Graph" button or fold/unfold a group node.
    </y:description>
    <y:keywords>
        <y:keyword>HierarchyManager</y:keyword>
        <y:keyword>recursive</y:keyword>
        <y:keyword>group</y:keyword>
        <y:keyword>node</y:keyword>
        <y:keyword>nested</y:keyword>
        <y:keyword>grouping</y:keyword>
        <y:keyword>hierarchical</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.partial">
  <y:displayname>Partial Layout Demos</y:displayname>
  <y:displaypriority>15</y:displaypriority>
  <y:description>

  <h1>yFiles Tutorial Demos for Partial Layout</h1>
  <p>
    This package contains tutorial source code demos that shows the usage of <code>PartialLayouter</code> in various
    use case scenarios. This layout algorithm changes the coordinates of a given set of graph elements (called
    <i>partial</i> elements) and leaves the location and size of all other elements (called <i>fixed</i> elements)
    unchanged. The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
    elements) has a good quality with respect to common graph drawing aesthetics.
  </p>
  </y:description>

    <y:demo javaname="demo.layout.partial.HierarchicPartialLayoutDemo" source="HierarchicPartialLayoutDemo.java">
        <y:displayname>HierarchicPartialLayoutDemo</y:displayname>
        <y:summary>Partial Layouter for hierarchic layout</y:summary>
        <y:description>
          <p>
            This demo shows how to apply <code>PartialLayouter</code> to hierarchic layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>
            
            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>
            
            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Automatic" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>
            
            <dt>Consider Hierarchy</dt>
            <dd>
              Specifies that the algorithm should place partial nodes (subgraph components) in a hierarchic
              manner, i.e., such that each predecessor of a node v is placed above v and each successor below v.
            </dd>
            
            <dt>Hierarchy Reorganization</dt>
            <dd>
              Specifies whether or not a postprocessing step should be applied to reduce the number of edges that
              do not comply with the hierarchy, i.e., edges whose target is placed in the same layer or above the 
              layer of the source.
            </dd>
            
            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>
            
            <dt>Minimal Layer Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent layers.
            </dd>
            
            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>

            <dt>Layout Orientation</dt>
            <dd>
              Specifies the layout orientation. "Auto" specifies that the orientation should be determined
              automatically.
            </dd>
          </dl>
          
          <h3>Additional Features</h3>
          
          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates 
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>hierarchic</y:keyword>
          <y:keyword>hierarchical</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.OrganicPartialLayoutDemo" source="OrganicPartialLayoutDemo.java">
        <y:displayname>OrganicPartialLayoutDemo</y:displayname>
        <y:summary>Partial Layouter for organic layout</y:summary>
        <y:description>
          <p>
            This demo shows how to apply <code>PartialLayouter</code> to organic layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>

            <dt>Placement Strategy</dt>
            <dd>
              Specifies the placement strategy.<br/>
              "Barycenter" specifies that each component should be placed close to the barycenter of its graph
              neighbors. <br/>
              "From Sketch" specifies that each component should be placed close to its original position.
            </dd>

            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Automatic" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>

            <dt>Snapping</dt>
            <dd>
              If enabled, the algorithm tries to align nodes with each other.
            </dd>

            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>

            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>hierarchic</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.OrthogonalPartialLayoutDemo" source="OrthogonalPartialLayoutDemo.java">
        <y:displayname>OrthogonalPartialLayoutDemo</y:displayname>
        <y:summary>Partial Layouter for orthogonal layout</y:summary>
        <y:description>
          <p>
            This demo shows how to apply <code>PartialLayouter</code> to orthogonal layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Grid Size</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes as well as the grid size.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.<br/>
              "Same Component" specifies that all partial nodes are assigned to the same component.
            </dd>

            <dt>Snapping</dt>
            <dd>
              If enabled, the algorithm tries to align nodes with each other.
            </dd>

            <dt>Use Sketch</dt>
            <dd>
              Specifies that each component should be placed close to its original position.
            </dd>

            <dt>Resize Fixed Groups</dt>
            <dd>
              Specifies that fixed groups may be resized.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>orthogonal</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.CircularPartialLayoutDemo" source="CircularPartialLayoutDemo.java">
        <y:displayname>CircularPartialLayoutDemo</y:displayname>
        <y:summary>Partial Layouter for circular layout</y:summary>
        <y:description>
          <p>
            This demo shows how to apply <code>PartialLayouter</code> to circular layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>
          <p>
            The demo allows to specify the following properties:
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Graphs" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>

            <dt>Placement Strategy</dt>
            <dd>
              Specifies the placement strategy.<br/>
              "Barycenter" specifies that each component should be placed close to the barycenter of its graph
              neighbors. <br/>
              "From Sketch" specifies that each component should be placed close to its original position.
            </dd>

            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Auto" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>

            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>

            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>circular</y:keyword>
          <y:keyword>partial layout</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.PartialLayoutBase" source="PartialLayoutBase.java" executable="false">
      <y:displayname>PartialLayoutBase</y:displayname>
      <y:description>Abstract base class for all <code>PartialLayouter</code> demos.</y:description>
      <y:keywords>
        <y:keyword>PartialLayouter</y:keyword>
        <y:keyword>partial</y:keyword>
        <y:keyword>layout</y:keyword>
      </y:keywords>
    </y:demo>

</y:package>
      <y:package javaname="demo.layout.withoutview">
  <y:displayname>Layout without yFiles View</y:displayname>
  <y:description>
<h1>yFiles Tutorial Layout Demos</h1>
<p>
The following source code samples demonstrate how to use the yFiles layout 
algorithms when the yFiles Viewer distribution is not present.
</p>
</y:description>

  <y:demo javaname="demo.layout.withoutview.DiagonalLayouter" source="DiagonalLayouter.java" executable="false">
    <y:displayname>DiagonalLayouter</y:displayname>
    <y:description>Implementation of a custom layouter that arranges the nodes
on a diagonal line. Edges will be routed with exactly one bend.
</y:description>
  <y:keywords>
<y:keyword>diagonal</y:keyword>
<y:keyword>layout</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.LayoutWithoutAView" source="LayoutWithoutAView.java">
    <y:displayname>LayoutWithoutAView</y:displayname>
    <y:description>Shows how to use layout and labeling algorithms without using classes 
that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.GroupingLayoutWithoutAView" source="GroupingLayoutWithoutAView.java">
    <y:displayname>GroupingLayoutWithoutAView</y:displayname>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of node
 and edge grouping in combination with the layout algorithms that are capable of
interpreting these sophisticated features. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>edge grouping</y:keyword>
<y:keyword>bus-style</y:keyword>
<y:keyword>routing</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.IncrementalLayoutWithoutAView" source="IncrementalLayoutWithoutAView.java">
    <y:displayname>IncrementalLayoutWithoutAView</y:displayname>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of the incremental
layout capabilities provided by IncrementalHierarchicLayouter. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.SwimlaneLayoutWithoutAView" source="SwimlaneLayoutWithoutAView.java">
    <y:displayname>SwimlaneLayoutWithoutAView</y:displayname>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of the swim lane
layout capabilities of IncrementalHierarchicLayouter. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>swimlane</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.PartitionGridLayoutWithoutAView" source="PartitionGridLayoutWithoutAView.java">
    <y:displayname>PartitionGridLayoutWithoutAView</y:displayname>
    <y:description>   
  This demo shows how to use the partition grid feature of IncrementalHierarchicLayouter
  without using classes that are only present in the yFiles Viewer Distribution.
  In this demo, nodes will be assigned to certain regions of the diagram,
  the so-called cells. The diagram will be arranged using hierarchical layout
  style, while nodes remain within the bounds of their cells.
  <br/>
  This demo displays the calculated coordinates in a simple graph viewer.
  Additionally it outputs the calculated coordinates of the graph layout to
  the console. This too can be achieved without the
  classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>  
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>swimlane</y:keyword>
<y:keyword>partition grid</y:keyword>
<y:keyword>partitioned layout</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.RecursiveGroupLayouterDemo" source="RecursiveGroupLayouterDemo.java">
    <y:displayname>RecursiveGroupLayouterDemo</y:displayname>
    <y:description>Shows how to layout the contents of group nodes each with a different layout style.
</y:description>
  <y:keywords>
<y:keyword>RecursiveGroupLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>grouping</y:keyword>
<y:keyword>nested</y:keyword>
<y:keyword>group nodes</y:keyword>
</y:keywords>
</y:demo>

</y:package>
      <y:package javaname="demo.layout.orthogonal">
  <y:displayname>Orthogonal</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Demos for Orthogonal Layout</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles orthogonal layout facilities.
    </p>
  </y:description>

  <y:demo javaname="demo.layout.orthogonal.UMLClassDiagramLayouterDemo" source="UMLClassDiagramLayouterDemo.java">
    <y:displayname>UMLClassDiagramLayouterDemo</y:displayname>
    <y:summary>
      This demo shows how <code>DirectedOrthogonalLayouter</code> and
      <code>OrthogonalEdgeRouter</code> can be used to nicely layout UML
      Class Diagrams in an orthogonal layout style.
    </y:summary>
    <y:description>
      <p>
        This demo shows how <code>DirectedOrthogonalLayouter</code> and
        <code>OrthogonalEdgeRouter</code> can be used to nicely layout UML
        Class Diagrams in an orthogonal layout style.
      </p>
      <p>
        Usually, there are different kind of relationships between the classes of an UML diagram.
        Some of the relationships are undirected (e.g. associations) while others are directed
        (e.g. generalizations and realizations). This demo arranges a diagram in a way that
        directed relationships point in a main layout direction(here bottom-to-top), while the
        undirected relationships will be arranged without such a direction constraint.
        Furthermore, all directed relationships of the same type sharing a common target node
        will be routed in a bus-like style. For this special task
        OrthogonalEdgeRouter will be used in combination with {@link EdgeGroupRouterStage}.
      </p>
      <p>
        The toolbar of this demo offers four additional items:
      </p>
      <ol>
        <li>
          A combobox that selects the type of relationship to be used: association (no arrow),
          generalization (arrow and solid line), and realization (arrow and dashed line).
        </li>
        <li>Layout button - to layout the diagram</li>
        <li>Layout From Sketch button - to layout the diagram, while obeying the layout of the given diagram</li>
        <li>Route Edges button - to route all edges of the diagram, while preserving the coordinates of the nodes</li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>UML</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>class</y:keyword>
      <y:keyword>diagram</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.module">
  <y:displayname>Interactive Layout Configuration</y:displayname>
  <y:description>
    <h1>yFiles Tutorial Module Demos</h1>
    <p>
      The following source code samples demonstrate how to use and
      write yFiles modules.
    </p>
  </y:description>

  <y:demo javaname="demo.layout.module.LayoutModuleDemo" source="LayoutModuleDemo.java">
    <y:displayname>LayoutModuleDemo</y:displayname>
    <y:description>
      Demonstrates how layout modules can be added to the GUI of an application.
      A layout module is a layout algorithm combined
      with an option dialog that allows to change the
      settings of a layout algorithm interactively
      (only available if layout is part of distribution).
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.DiagonalLayoutModule" source="DiagonalLayoutModule.java" executable="false">
    <y:displayname>DiagonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for the demo
      Layouter
      <a href="../withoutview/DiagonalLayouter.java">DiagonalLayouter</a>
      .
      Additionally, this class can be executed separately. In this case it shows off
      the internationalization and serialization features of the OptionHandler class.
      By launching the module class using a two letter language constant as an
      argument, the dialog will be internationalized in that language if the
      corresponding localized properties file is available. Try either 'en' for
      English or 'de' for German.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>internationalization</y:keyword>
<y:keyword>serialization</y:keyword>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>language</y:keyword>
<y:keyword>DiagonalLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.ComponentLayoutModule" source="ComponentLayoutModule.java" executable="false">
    <y:displayname>ComponentLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for ComponentLayouter. 
      It is similar to ComponentLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>component</y:keyword>
<y:keyword>ComponentLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.FamilyTreeLayoutModule" source="FamilyTreeLayoutModule.java" executable="false">
    <y:displayname>FamilyTreeLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for
      FamilyTreeLayouter.
      It is similar to FamilyTreeLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>FamilyTreeLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.CircularLayoutModule" source="CircularLayoutModule.java" executable="false">
    <y:displayname>CircularLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for CircularLayouter.
      It is similar to CircularLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>CircularLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.HierarchicLayoutModule" source="HierarchicLayoutModule.java" executable="false">
    <y:displayname>HierarchicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for HierarchicLayouter
      and HierarchicGroupLayouter.
      It is similar to HierarchicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>HierarchicLayouter</y:keyword>
<y:keyword>HierarchicGroupLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.IncrementalHierarchicLayoutModule" source="IncrementalHierarchicLayoutModule.java" executable="false">
    <y:displayname>IncrementalHierarchicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for IncrementalHierarchicLayouter.
      It is similar to IncrementalHierarchicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.OrganicLayoutModule" source="OrganicLayoutModule.java" executable="false">
    <y:displayname>OrganicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrganicLayouter.
      It is similar to OrganicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrganicLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.SmartOrganicLayoutModule" source="SmartOrganicLayoutModule.java" executable="false">
    <y:displayname>SmartOrganicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for SmartOrganicLayout.
      It is similar to SmartOrganicLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>SmartOrganicLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.OrthogonalLayoutModule" source="OrthogonalLayoutModule.java" executable="false">
    <y:displayname>OrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrthogonalLayouter
      and OrthogonalGroupLayouter respectively.
      It is similar to OrthogonalLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrthogonalLayouter</y:keyword>
<y:keyword>OrthogonalGroupLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.DirectedOrthogonalLayoutModule" source="DirectedOrthogonalLayoutModule.java" executable="false">
    <y:displayname>DirectedOrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for DirectedOrthogonalLayout. 
      It is similar to DirectedOrthogonalLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>DirectedOrthogonalLayouter</y:keyword>
<y:keyword>UML</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.CompactOrthogonalLayoutModule" source="CompactOrthogonalLayoutModule.java" executable="false">
    <y:displayname>CompactOrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for CompactOrthogonalLayout. 
      It is similar to CompactOrthogonalLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>CompactOrthogonalLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.TreeLayoutModule" source="TreeLayoutModule.java" executable="false">
    <y:displayname>TreeLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for the
      different tree layouts in yFiles.
      It is similar to TreeLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>tree</y:keyword>
<y:keyword>ARTreeLayouter</y:keyword>
<y:keyword>HVTreeLayouter</y:keyword>
<y:keyword>BalloonLayouter</y:keyword>
<y:keyword>TreeLayouter</y:keyword>
<y:keyword>TreeReductionStage</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.OrthogonalEdgeRouterModule" source="OrthogonalEdgeRouterModule.java" executable="false">

    <y:displayname>OrthogonalEdgeRouterModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for
      OrthogonalEdgeRouter. It is similar to
      OrthogonalEdgeRouterModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrthogonalEdgeRouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.ChannelEdgeRouterModule" source="ChannelEdgeRouterModule.java" executable="false">
    <y:displayname>ChannelEdgeRouterModule</y:displayname>
    <y:description>
This module represents an interactive configurator and launcher for ChannelEdgeRouter. 
It is similar to ChannelEdgeRouterModule found in the yFiles package y.module.
    </y:description>
    <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
      <y:keyword>ChannelEdgeRouter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.OrganicEdgeRouterModule" source="OrganicEdgeRouterModule.java" executable="false">
    <y:displayname>OrganicEdgeRouterModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrganicEdgeRouter. 
      It is similar to OrganicEdgeRouterModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrganicEdgeRouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.LabelingModule" source="LabelingModule.java" executable="false">
    <y:displayname>LabelingModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for the yFiles
      labeling algorithms.
      It is similar to LabelingModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>labeling</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>GreedyMISLabeling</y:keyword>
<y:keyword>SALabeling</y:keyword>
</y:keywords>
</y:demo>

</y:package>
      <y:package javaname="demo.layout.genealogy">
  <y:displayname>Genealogy</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Demos for Genealogical Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles layout facilities for genealogical data.
    </p>
  </y:description>
  <y:demo javaname="demo.layout.genealogy.FamilyTreeDemo" source="FamilyTreeDemo.java">
    <y:displayname>FamilyTreeDemo</y:displayname>
    <y:summary>
      This Demo shows how to use the FamilyTreeLayouter.
    </y:summary>
    <y:description>
      This Demo shows how to use the FamilyTreeLayouter.
      <br/>
      <b>Usage:</b>
      <br/>
      Load a Gedcom file with "Load..." from the "File" menu. The gedcom file is converted on the fly into GraphML
      and loaded into the graph by the demo.layout.genealogy.iohandler.GedcomHandler. After loading,
      the graph will be laid out by the y.layout.genealogy.FamilyTreeLayouter.
      NOTE: you will find some sample files in your &lt;src&gt;/demo/view/layout/genealogy/samples folder
      <br/>
      To re-layout the graph press the "layout" button. An options dialog will open where you can modify
      some basic and advanced options. Clicking "OK" will induce a new layout with the new settings.
      <br/>
      To load some sample graphs which are provided with this demo select one from the "Examples" ComboBox.
      There are four different family trees with different complexity provided.
      NOTE: for this feature, Gedcom files (ending: .ged) must be exported as resources.
      <br/>
      Clicking on a node will collapse the graph to two generations around the clicked node. The "Show all" button
      will expand the graph again.
    </y:description>
<y:keywords>
      <y:keyword>family</y:keyword>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>GEDCOM</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>FamilyTreeLayouter</y:keyword>
      <y:keyword>genealogy</y:keyword>
</y:keywords>
  </y:demo>
</y:package>
    </y:package>
    <y:package javaname="demo.view">
  <y:displayname>Graph Visualization</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial View Demos</h1>

    <p>
      The following tutorial view demos are in this package:
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="realizer/README.html">demo.view.realizer</a>
        </td>
        <td>
          The contained tutorial demos describe how to use, customize, and extend
          diverse NodeRealizer and EdgeRealizer classes.
        </td>
      </tr>

      <tr>
        <td>
          <a href="rendering/README.html">demo.view.rendering</a>
        </td>
        <td>
          Centers around advanced rendering aspects of the graph view.
          It is shown how to use auxiliary rendering classes <code>Drawable</code>,
          <code>BackgroundRenderer</code>, and <code>BridgeCalculator</code>.
        </td>
      </tr>

      <tr>
        <td>
          <a href="viewmode/README.html">demo.view.viewmode</a>
        </td>
        <td>
          Shows how to use, customize, and extend diverse ViewMode classes.
          View modes provide the base functionality to handle
          mouse-based interaction that happens in a view.
        </td>
      </tr>

      <tr>
        <td>
          <a href="anim/README.html">demo.view.anim</a>
        </td>
        <td>
          Contains demos that center around the diverse animation effects that
          can be applied to graph elements and to graph views.
        </td>
      </tr>

      <tr>
        <td>
          <a href="advanced/README.html">demo.view.advanced</a>
        </td>
        <td>
          Shows advanced features like using a model graph and having multiple different 
          views on it, or temporarily preventing parts of a graph from being editable.
          <br/>
          Also, contains a demo that employs special nodes with a fixed set of allowed 
          connection points (known as ports).
        </td>
      </tr>

      <tr>
        <td>
          <a href="application/README.html">demo.view.application</a>
        </td>
        <td>
          Shows how to use application features like drag and drop, print previewing, 
          clipboard functionality, and undoability. 
          Also, local views are presented, swimlane support, and searching in a 
          graph.
        </td>
      </tr>

      <tr>
        <td>
          <a href="hierarchy/README.html">demo.view.hierarchy</a>
        </td>
        <td>
        These demos show how to write applications that can manage a hierarchy of 
        nested and grouped graphs. 
        Predefined actions are used that perform navigational and structural tasks 
        on the graph hierarchy. 
        Furthermore, creating customized actions is presented as well.
        </td>
      </tr>

      <tr>
        <td>
              <a href="applet/README.html">demo.view.applet</a>
            </td>
        <td>
          Features a self-contained demo setup that shows how to deploy yFiles-based applications 
          as Java applets inside a web browser.
        </td>
      </tr>

      <tr>
        <td>
              <a href="orgchart/README.html">demo.view.orgchart</a>
            </td>
        <td>
          Extensive demo application that presents an organization chart in a visually 
          rich manner.
          <br/>
          Many aspects of yFiles are demonstrated, for example, realizer and view 
          mode customization, or animations. 
          Implementation of the demo's features, like level of detail (LoD) rendering, 
          or synchronization between a business model and the graph structure using 
          yFiles is shown in detail.
        </td>
      </tr>

      <tr>
        <td>
              <a href="flowchart/README.html">demo.view.flowchart</a>
            </td>
        <td>
          Simple flowchart editor application that comes with a large set
          of flowchart symbols and a reusable palette component.
        </td>
      </tr>
    </table>
  </y:description>

  <y:demo javaname="demo.view.SimpleDemo" source="SimpleDemo.java">
    <y:displayname>SimpleDemo</y:displayname>
    <y:description>
      The yFiles view says "Hello World." Shows how to display a graph
      viewer/editor component inside a frame. Try clicking into
      the view to create new nodes, pressing the left mouse button
      over a node and dragging the mouse to another node to create an edge,
      clicking a node to select it...</y:description>
    <y:keywords>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>JFrame</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.BuildGraphDemo" source="BuildGraphDemo.java">
    <y:displayname>BuildGraphDemo</y:displayname>
    <y:description>
      Shows how to build a Graph2D with different node types
      and styles applied to its elements. Try adding new nodes and edges with
      the mouse.
    </y:description>
    <y:keywords>
      <y:keyword>Graph2D</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>EditMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.ViewActionDemo" source="ViewActionDemo.java">
    <y:displayname>ViewActionDemo</y:displayname>
    <y:description>
      Demonstrates some actions that can be performed on the view or
	    the contents of the view:
      <ul>
        <li>remove selected parts of the view</li>
        <li>zoom out of the view</li>
        <li>zoom in on the view</li>
        <li>fit view content to the size of the view</li>
        <li>print contents of the view</li>
        <li>load a graph in GraphML format</li>
        <li>save a graph in GraphML format</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>interaction</y:keyword>
      <y:keyword>editing</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>print</y:keyword>
      <y:keyword>actions</y:keyword>
      <y:keyword>load</y:keyword>
      <y:keyword>save</y:keyword>
      <y:keyword>fit content</y:keyword>
    </y:keywords>
  </y:demo>

<y:package javaname="demo.view.application">
  <y:displayname>Application</y:displayname>
  <y:displaypriority>80</y:displaypriority>
  <y:description>
    <h1>Application-specific yFiles Tutorial View Demos</h1>
    <p>
    The following tutorial view demos show how to use basic application
    features like drag and drop, print previewing, clipboard functionality, and
    undoability.
    </p>
  </y:description>

  <y:demo javaname="demo.view.application.UndoRedoDemo" source="UndoRedoDemo.java">
    <y:displayname>UndoRedoDemo</y:displayname>
    <y:summary>Shows how to use undo/redo functionality provided by yFiles.</y:summary>
    <y:description>
      <p>
        Shows how to use undo/redo functionality provided by yFiles.
      </p>
      <p>
        <b>Usage:</b> click on the view pane to draw a graph. To trigger an
        undo/redo event, press the corresponding button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>undo</y:keyword>
      <y:keyword>redo</y:keyword>
      <y:keyword>backup</y:keyword>
      <y:keyword>realizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.ClipboardDemo" source="ClipboardDemo.java">
    <y:displayname>ClipboardDemo</y:displayname>
     <y:summary>
      Demonstrates how to use the yFiles clipboard functionality to cut, copy, and paste parts of a graph.
    </y:summary>
    <y:description>
      <p>
        Demonstrates how to use the yFiles clipboard functionality to cut, copy,
        and paste parts of a graph.
      </p>
      <p>
        <b>Usage:</b> select graph elements and press the cut or copy button
        (or the corresponding key combination) to trigger the corresponding
        action and copy the elements to the clipboard. To paste elements from
        the clipboard press the paste button (or the corresponding key
        combination).
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>clipboard</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.DragAndDropDemo" source="DragAndDropDemo.java">
    <y:displayname>DragAndDropDemo</y:displayname>
    <y:summary>
      Shows how to drag different node and edge types from a list and how to drop
      them onto a graph view.
    </y:summary>
    <y:description>
      Shows how to drag different node and edge types from a list and how to drop
      them onto a graph view. Dragging the image of a node type from the list to the
      the main view creates a node of that type at the drop location. To create an edge
      of a specific type drag its image from the list onto an already existing node in
      the view. This starts the creation of an edge starting at the drop target node.
      Snap lines can be activated/deactivated for node drag and drop with the Snapping
      button.
    </y:description>
    <y:keywords>
      <y:keyword>drag</y:keyword>
      <y:keyword>drop</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.LocalViewDemo" source="LocalViewDemo.java">
    <y:displayname>LocalViewDemo</y:displayname>
    <y:summary>
      Demonstrates local views, a feature that uses a given (model) graph to
      create a (hopefully smaller) graph which emphasizes a certain aspect of
      the original graph.
    </y:summary>
    <y:description>
      <p>
      Demonstrates local views, a feature that uses a given (model) graph to create a
      (hopefully smaller) graph which emphasizes a certain aspect of the original
      graph.
      </p>
      <p>
      A local view displays a subset of a graph's elements. The intent is usually to
      improve performance, usability, or view experience in general (or all of the
      before mentioned).
      </p>
      <h2>Main Graph View</h2>
        <p>
        The display and editor area to the right. Several ways to interact with its
        graph are possible and may trigger an update of the local view (the display
        area to the left) depending on the chosen <em>update trigger</em> (see
        below).
        </p>

        <h3>Mouse Interaction</h3>
        <dl>
          <dt>Left Click on Node</dt>
          <dd>Selects the node.</dd>
          <dt>Left Click on Canvas</dt>
          <dd>Creates a new node.</dd>
          <dt>Left Mouse Drag on Canvas</dt>
          <dd>Selects multiple graph elements.</dd>
          <dt>Left Mouse Drag on Node</dt>
          <dd>Creates an edge.</dd>
          <dt>Right Mouse Drag</dt>
          <dd>Moves the diagram within the view.</dd>
          <dt>Mouse Wheel</dt>
          <dd>Changes the zoom level of the view.</dd>
        </dl>

        <h3>Key Bindings</h3>
        <dl>
          <dt>Left Arrow Key</dt>
          <dd>Selects a node to the left of the currently selected node</dd>
          <dt>Right Arrow Key</dt>
          <dd>Selects a node to the right of the currently selected node</dd>
          <dt>Up Arrow Key</dt>
          <dd>Selects a node above the currently selected node</dd>
          <dt>Down Arrow Key</dt>
          <dd>Selects a node below the currently selected node</dd>
        </dl>

      <h2>Local Graph View</h2>
        <p>
        The display area to the left.
        </p>

       <h3>Mouse Interaction</h3>
       <dl>
         <dt>Double Click on Node</dt>
         <dd>Selects and centers the node in the main view if possible.</dd>
         <dt>Double Click on Edge</dt>
         <dd>Selects and centers the edge in the main view if possible.</dd>
       </dl>

      <h2>Settings</h2>
        <p>
          The available settings govern when and how to update the local graph view.
        </p>

        <h3>Update Trigger</h3>
        <dl>
          <dt>Mouse Hover</dt>
          <dd>The local view is updated if the mouse hovers (for about 1/10 of a
              second) over a node or edge in the main graph view.
              The node or edge over which the mouse hovers is the single input
              element for the chosen update strategy (see below).</dd>
          <dt>Selection Change</dt>
          <dd>The local view is updated if the selection state of nodes or edges is
              changed in the main graph view changes.
              Either all selected nodes or all selected edges (as appropriate)
              are used as input elements for the chosen update strategy (see
              below).</dd>
        </dl>

        <h3>Node Strategies</h3>
        <p>
          Available strategies to create local views for input nodes.
          Clicking on the corresponding radio button will activate the strategy
          and possibly display additional settings.
        </p>
        <dl>
          <dt>Neighborhood</dt>
          <dd>Displays all nodes that are reachable by directed or undirected paths
              upto a specific length.
            <dl>
              <dt class="inner">Included Nodes</dt>
              <dd>
                Determines which nodes make up the neighborhood of the input
                nodes.
                <br/>
                <span class="keyword">Predecessors</span> means all nodes that are
                reachable by outgoing edges only.
                <br/>
                <span class="keyword">Successors</span> means all nodes that are
                reachable by ingoing edges only.
                <br/>
                <span class="keyword">Predecessors and Successors</span> means the
                union of the two aforementioned node sets.
                <br/>
                <span class="keyword">All Neighbors</span> means all nodes that are
                reachable by undirected edge paths.
              </dd>
              <dt class="inner">Maximum Graph Distance</dt>
              <dd>The maximum number of edges to traverse to reach a neighborhood
                  node.</dd>
              <dt class="inner">Included Edges</dt>
              <dd>
                Determines the edges that are displayed in the local view.
                <br/>
                <span class="keyword">None</span> means no edges at all.
                <br/>
                <span class="keyword">Subgraph Edges</span> means all edges
                that connect any two of the displayed nodes.
                <br/>
                <span class="keyword">Shortest Paths</span> means the edges that lie
                on the shortest path from one of the input nodes to one of the other
                displayed nodes.
              </dd>
            </dl>
          </dd>
          <dt>Common Parent Group</dt>
          <dd>
            Displays all nodes that share the same parent group node as one of the
            input nodes and edges connecting only these nodes.
            <br/>
            <span class="keyword">Include Descendants</span> determines whether
            the contents of displayed group nodes should be displayed as well.
          </dd>
          <dt>Ancestor Groups</dt>
          <dd>
            Displays the input nodes and all of their ancestor group nodes.
            A group node is considered to be the ancestor of another node if it
            either contains the node itself or one of its ancestor nodes.
            <br/>
            <span class="keyword">Include Focus Nodes</span> determines whether
            the input nodes are displayed as well.
          </dd>
          <dt>Folder Contents</dt>
          <dd>
            Displays the contents or inner graphs of all input nodes that are
            folder nodes. The nodes labeled <em>y.util</em> and <em>y.util.pq</em>
            are the only folder nodes in the sample diagram that is displayed in
            the main graph view.
            <br/>
            <span class="keyword">Always Include Folders</span> means that for each
            input folder node a group node representative is created in the local
            view.
            <br/>
            <span class="keyword">Include Folders As Needed</span> means that a
            group node representative for input folder nodes is created if the
            contents of more than one folder are displayed.
            <br/>
            <span class="keyword">Never Include Folders</span> means that input
            folder nodes will not be displayed in the local view.
          </dd>
          <dt>Selected Subgraph</dt>
          <dd>Displays the selected input nodes and all edges connecting only these
              nodes.</dd>
        </dl>

        <h3>Edge Strategies</h3>
        <p>
          Available strategies to create local views for input edges.
          Clicking on the corresponding radio button will activate the strategy
          and possibly display additional settings.
        </p>
        <dl>
          <dt>Source and Target</dt>
          <dd>Displays the input edges and their respective source and target
              nodes.</dd>
          <dt>Edge Group</dt>
          <dd>
            Displays all edges that share source and/or target node (depending on
            the selection states of the <span class="keyword">Source</span> and
            <span class="keyword">Target</span> settings to the right) with one
            of the input edges.</dd>
        </dl>
    </y:description>
    <y:keywords>
      <y:keyword>local</y:keyword>
      <y:keyword>view</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>relation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.PrintPreviewDemo" source="PrintPreviewDemo.java">
    <y:displayname>PrintPreviewDemo</y:displayname>
    <y:summary>
      Demonstrates how to use the yFiles print preview panel and how to
      add a title and a footer to a printed page or poster.
    </y:summary>
    <y:description>
      <p>
        Demonstrates how to use the yFiles print preview panel and how to
        add a title and a footer to a printed page or poster.
      </p>
      <p>
        <b>Usage:</b> draw a graph by clicking on the view pane. The printer
        preview is opened by pressing the corresponding button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>print</y:keyword>
      <y:keyword>printing</y:keyword>
      <y:keyword>preview</y:keyword>
      <y:keyword>poster</y:keyword>
      <y:keyword>row</y:keyword>
      <y:keyword>column</y:keyword>
      <y:keyword>title</y:keyword>
      <y:keyword>footer</y:keyword>
      <y:keyword>margin</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.SwimlaneDemo" source="SwimlaneDemo.java">
    <y:displayname>SwimlaneDemo</y:displayname>
    <y:summary>
      Demonstrates how to use and customize y.view.tabular.TableGroupNodeRealizer to work as a pool
      having several swim lanes and milestones.
    </y:summary>
    <y:description>
      Demonstrates how to use and customize y.view.tabular.TableGroupNodeRealizer to work as a pool
      having several swim lanes and milestones.
      <h3>Working with the table structure</h3>
      <dl>
         <dt>Adding new rows/columns</dt>
         <dd>A new row or column can be added by dragging the corresponding icon from list and dropping it onto a table group node.</dd>

         <dt>Selecting rows/columns</dt>
         <dd>A row or column can be selected by clicking on it's header.</dd>

         <dt>Removing rows/columns</dt>
         <dd>A selected row or column can be removed using the <code>DELETE</code> key or the corresponding icon in the tool bar.</dd>

         <dt>Reordering rows/columns</dt>
         <dd>A selected row or column can be moved by dragging it on it's header to a different position in the table.</dd>

         <dt>Resizing rows/columns</dt>
         <dd>A row or column can be resized by dragging it' bottom respectively right border.
             If <code>SHIFT</code> is pressed at the beginning of the resize gesture, the sizes of the two attached stripes
         are redistributed.</dd>

          <dt>Editing the label of a row/column</dt>
          <dd>The label of a row or column can be edited by either selecting it and pressing the <code>F2</code> key or by double clicking it's header.</dd>
      </dl>

      <h3>Working with the table content</h3>
      <dl>
          <dt>Adding content nodes to the table</dt>
          <dd>New content (group) nodes can be dragged from the list onto a table.</dd>

          <dt>Associating a node with a row or column</dt>
          <dd>A node is associated to the row and column it's center coordinates lie in. Therefore it can be associated to another row or column by simply dragging in to a new position.</dd>

          <dt>Laying out the table content</dt>
          <dd>A new layout for the tables and their contents can be calculated by pressing the layout button in the tool bar.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>TableGroupNodeRealizer</y:keyword>
      <y:keyword>swim lane</y:keyword>
      <y:keyword>column</y:keyword>
      <y:keyword>row</y:keyword>
      <y:keyword>table</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.SearchDemo" source="SearchDemo.java">
    <y:displayname>SearchDemo</y:displayname>
    <y:summary>
      Demonstrates how to find nodes in a graph that match a specific criterion
      and how to visually present all matching nodes in simple way.
    </y:summary>
    <y:description>
      Demonstrates how to find nodes in a graph that match a specific criterion
      and how to visually present all matching nodes in simple way.
      <h2>Usage</h2>
      <p>
        Type the text you want to find into the <em>Find</em> text field in the
        toolbar. As you type, all nodes whose labels contain this text will
        be automatically highlighted. Click <em>Next</em> or <em>Previous</em>
        to select specific matching nodes of click <em>Select All</em> to select
        all matching nodes.
      </p>
      <p>
        Nodes whose labels contain the entered text are highlighted using a thick
        orange border. Those of these nodes that are selected (either using the
        <em>Next</em>, <em>Previous</em>, or <em>Select All</em> controls or by
        clicking on the node) are highlighted using a thick red border.
      </p>
      <h2>Global Key Bindings</h2>
      <dl>
        <dt>F3 Function Key</dt>
        <dd>Selects the next matching node.
            Same as clicking <em>Next</em> in the toolbar.</dd>
        <dt>Escape Key</dt>
        <dd>Clears the <em>Find</em> text field and any result highlighting.</dd>
      </dl>
      <h2>Search Field Key Bindings</h2>
      <dl>
        <dt>Return Key</dt>
        <dd>Selects the next matching node.
            Same as clicking <em>Next</em> in the toolbar.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>find node</y:keyword>
      <y:keyword>search nodes</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.applet">
  <y:displayname>Sample: Applet</y:displayname>
  <y:displaypriority>10</y:displaypriority>
  <y:description>
  <h1>yFiles Applet Demos</h1>
  <p>
  The following tutorial view demos show how to deploy yFiles-based applications 
  as applets inside a web browser.
  </p>
  </y:description>

  <y:demo javaname="demo.view.applet.AppletDemo" source="AppletDemo.java" executable="false">
    <y:displayname>AppletDemo</y:displayname>
    <y:description>
    Shows how to deploy a yFiles-based application as an applet inside a web browser. 
    <br/>
    An <a href="build.xml">Ant build script</a> is used to compile and deploy the 
    applet's application classes (<a href="DemoEditor.java">demo.view.applet.DemoEditor</a>) 
    into a Jar file in this directory. 
    The HTML file <code>applet.html</code> can then be opened in the web browser.
    </y:description>
    <y:keywords>
      <y:keyword>applet</y:keyword>
      <y:keyword>deploy</y:keyword>
      <y:keyword>deployment</y:keyword>
      <y:keyword>web</y:keyword>
      <y:keyword>browser</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.orgchart">
  <y:displayname>Sample: Organization Chart</y:displayname>
  <y:displaypriority>20</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Organization Chart Demo</h1>
    <p>
    This demo visualizes an organization chart. This comprehensive demo shows
    many aspects of yFiles. In particular it shows how to
    </p>
    <ul>
      <li>visualize XML-formatted data as a graph</li>
      <li>create a tree diagram from a <code>javax.swing.tree.TreeModel</code>
            </li>
      <li>create customized node realizers that show text and multiple icons</li>
      <li>create a customized <code>y.view.NavigationMode</code> view mode</li>
      <li>create fancy roll-over effects when hovering over nodes</li>
      <li>implement level of detail (LoD) rendering of graphs</li>
      <li>synchronize the selection state of <code>javax.swing.JTree</code> and <code>y.view.Graph2D</code>
            </li>
      <li>customize <code>y.layout.tree.GenericTreeLayouter</code> to make it a perfect match for laying out organization charts</li>
      <li>create local views for a large diagram</li>
      <li>apply incremental layout and apply nice fade in and fade out effects to added or removed elements</li>
      <li>implement and use keyboard navigation for <code>y.view.Graph2DView</code>
            </li>
    </ul>
    <p>
    This demo is composed of multiple classes. Class <code>demo.view.OrgChartDemo</code> is the organization chart application and driver class
    that organizes the UI elements and makes use of the swing component <code>demo.view.orgchart.JOrgChart</code>. The model data used in this sample
    is represented by the Swing tree model <code>demo.view.orgchart.OrgChartTreeModel</code>. Class <code>demo.view.orgchart.JOrgChart</code>
    builds upon the more generic tree chart component <code>demo.view.orgchart.JTreeChart</code>. In a nutshell, JTreeChart
    visualizes a generic TreeModel and includes all the viewer logic, while JOrgChart visualizes a OrgChartTreeModel and
    customizes the look and feel of the component. Also it customizes the look and feel of the component to make it suitable for
    organization charts.
    </p>
    <p>
    Directory <a href="resources">resources</a> contains the XML-based organization chart sample file, a help file, and application icons.
    </p>
  </y:description>

  <y:demo javaname="demo.view.orgchart.OrgChartDemo" source="OrgChartDemo.java">
    <y:displayname>OrgChartDemo</y:displayname>
    <y:summary>
      The main demo program in this tutorial.
    </y:summary>
    <y:description>
      <p>
      This demo visualizes an organization chart. This comprehensive demo shows
      many aspects of yFiles. In particular it shows how to
      </p>
      <ul>
      <li>visualize XML-formatted data as a graph</li>
      <li>create a tree diagram from a <code>javax.swing.tree.TreeModel</code>
              </li>
      <li>create customized node realizers that show text and multiple icons</li>
      <li>create a customized <code>y.view.NavigationMode</code> view mode</li>
      <li>create fancy roll-over effects when hovering over nodes</li>
      <li>implement level of detail (LoD) rendering of graphs</li>
      <li>synchronize the selection state of <code>javax.swing.JTree</code> and <code>y.view.Graph2D</code>
              </li>
      <li>customize <code>y.layout.tree.GenericTreeLayouter</code> to make it a perfect match for laying out organization charts</li>
      <li>create local views for a large diagram</li>
      <li>apply incremental layout and apply nice fade in and fade out effects to added or removed elements</li>
      <li>implement and use keyboard navigation for <code>y.view.Graph2DView</code>
              </li>
      </ul>
      <p>
      This demo is composed of multiple classes. Class <code>demo.view.orgchart.OrgChartDemo</code> is the organization chart application and driver class
      that organizes the UI elements and makes use of the Swing component <code>demo.view.orgchart.JOrgChart</code>. The model data used in this sample
      is represented by the Swing tree model <code>demo.view.orgchart.OrgChartTreeModel</code>. Class <code>demo.view.orgchart.JOrgChart</code>
      builds upon the more generic tree chart component <code>demo.view.orgchart.JTreeChart</code>. In a nutshell, JTreeChart 
      visualizes a generic TreeModel and includes all the viewer logic, while JOrgChart visualizes a OrgChartTreeModel and
      customizes the look and feel of the component. Also it customizes the look and feel of the component to make it suitable for
      organization charts.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>


  <y:demo javaname="demo.view.orgchart.OrgChartTreeModel" source="OrgChartTreeModel.java" executable="false">
    <y:displayname>OrgChartTreeModel</y:displayname>
    <y:description>TreeModel that uses Employee as TreeNodes.</y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
    <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.JOrgChart" source="JOrgChart.java" executable="false">
    <y:displayname>JOrgChart</y:displayname>
    <y:description>Organization chart component that builds upon the more generic tree chart component <code>demo.view.orgchart.JTreeChart</code>.
    It visualizes a <code>demo.view.orgchart.OrgChartTreeModel</code>. Also it customizes the look and feel of the component to make it suitable for
    organization charts. TreeModel that uses Employee as TreeNodes
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.JTreeChart" source="JTreeChart.java" executable="false">
    <y:displayname>JTreeChart</y:displayname>
    <y:description>Tree chart component that allows to display local views of the tree.
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.KeyboardNavigation" source="KeyboardNavigation.java" executable="false">
    <y:displayname>KeyboardNavigation</y:displayname>
    <y:description>Factory class that provides <code>java.awt.event.KeyListener</code> implementations suitable for
    navigating within Graph2DView.
    </y:description>
    <y:keywords>
      <y:keyword>keyboard</y:keyword>
      <y:keyword>keyboard navigation</y:keyword>
      <y:keyword>KeyListener</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.anim">
  <y:displayname>Animations</y:displayname>
  <y:displaypriority>60</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Animation Demos</h1>
    <p>
      This package contains demos that center around the diverse animation effects that
      can be applied to graph elements and to graph views.
    </p>
  </y:description>

  <y:demo javaname="demo.view.anim.AnimatedStructuralChangesDemo" source="AnimatedStructuralChangesDemo.java">
    <y:displayname>AnimatedStructuralChangesDemo</y:displayname>
    <y:description>
      Demonstrates how to combine animation effects for structural graph changes
      with animated graph layout changes.
    </y:description>
    <y:keywords>
      <y:keyword>animation</y:keyword>
      <y:keyword>structure</y:keyword>
      <y:keyword>change</y:keyword>
      <y:keyword>layout</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.AnimationEffectsDemo" source="AnimationEffectsDemo.java">
    <y:displayname>AnimationEffectsDemo</y:displayname>
    <y:description>
      Shows various animation effects for graph elements and graph views:
      <ul>
        <li>fade in and fade out for nodes and/or edges</li>
        <li>resizing of nodes</li>
        <li>edge traversals</li>
        <li>animated loading and clearing of graph structures</li>
        <li>animated zooming</li>
        <li>animated camera movement</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>fade</y:keyword>
      <y:keyword>fading</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>zooming</y:keyword>
      <y:keyword>camera</y:keyword>
      <y:keyword>movement</y:keyword>
      <y:keyword>resize</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.LabelAnimationDemo" source="LabelAnimationDemo.java">
    <y:displayname>LabelAnimationDemo</y:displayname>
    <y:description>
      Demonstrates how to animate label movement along an edge.
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>move</y:keyword>
      <y:keyword>moving</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>path</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.EaseInEaseOutDemo" source="EaseInEaseOutDemo.java">
    <y:displayname>EaseInEaseOutDemo</y:displayname>
    <y:description>
      Demonstrates how to apply ease in and ease out effects to animations on
      the basis of animated node movements.
    </y:description>
    <y:keywords>
      <y:keyword>animation</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>move</y:keyword>
      <y:keyword>moving</y:keyword>
      <y:keyword>ease</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.FadeInFadeOutDemo" source="FadeInFadeOutDemo.java">
    <y:displayname>FadeInFadeOutDemo</y:displayname>
    <y:description>
      Demonstrates how to animate node creation and deletion with a
      specialized <code>GraphListener</code>.
    </y:description>
    <y:keywords>
      <y:keyword>listener</y:keyword>
      <y:keyword>event</y:keyword>
      <y:keyword>fade</y:keyword>
      <y:keyword>fading</y:keyword>
      <y:keyword>effect</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.rendering">
  <y:displayname>Renderers</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial View Rendering Demos</h1>
    <p>
    The following tutorial demos center around advanced rendering aspects of the graph view.
    It is shown how to use auxiliary rendering classes <code>Drawable</code>,
    <code>BackgroundRenderer</code>, and <code>BridgeCalculator</code>.
    </p>
  </y:description>

  <y:demo javaname="demo.view.rendering.BridgeDemo" source="BridgeDemo.java">
    <y:displayname>BridgeDemo</y:displayname>
    <y:description>
      Demonstrates how to utilize <code>BridgeCalculator</code> to draw bridges or gaps
      for crossing edges.
    </y:description>
    <y:keywords>
      <y:keyword>bridge</y:keyword>
      <y:keyword>BridgeCalculator</y:keyword>
      <y:keyword>gap</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>cross</y:keyword>
      <y:keyword>crossing</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.rendering.BackgroundDemo" source="BackgroundDemo.java">
    <y:displayname>BackgroundDemo</y:displayname>
    <y:summary>
      Demonstrates how to use background images in the view.
    </y:summary>
    <y:description>
      <p>
      Demonstrates how to use background images in the view.
      </p>
      <p>
      <b>Usage:</b> Create some nodes and try the different background settings available
      via the toolbar button. Try changing the window size, zooming in and out and
      moving the view port by right dragging.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>background</y:keyword>
      <y:keyword>render</y:keyword>
      <y:keyword>rendering</y:keyword>
      <y:keyword>BackgroundRenderer</y:keyword>
      <y:keyword>image</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.rendering.DrawablesDemo" source="DrawablesDemo.java">
    <y:displayname>DrawablesDemo</y:displayname>
    <y:summary>
      This demo shows how to add objects of type Drawable to a Graph2DView.
    </y:summary>
    <y:description>
      This demo shows how to add objects of type Drawable to
      a Graph2DView and how to implement such a Drawable object.
      Drawables represent graphical objects that can be displayed
      by a Graph2DView. The main purpose of Drawables is to highlight
      certain regions of the displayed graph.
      <br/>
      The Drawable implemented in this demo draws itself as a box
      drawn underneath the displayed graph. The size and location of the box changes
      dynamically as the bounding box of the graph changes.
    </y:description>
    <y:keywords>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>implementation</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.realizer">
  <y:displayname>Nodes and Edges</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Realizer Demos</h1>
    <p>
      The following tutorial demos describe how to use, customize, and extend
      diverse NodeRealizer and EdgeRealizer classes.
      Among other user interface aspects, a realizer defines the way a graph element
      is rendered.
    </p>
    <p>
      <b>Note:</b> Except for the implementation of <code>demo.view.realizer.StateNodeRealizer</code>,
      all classes listed here are also executable.
    </p>
  </y:description>

  <y:demo javaname="demo.view.realizer.VisualFeatureDemo" source="VisualFeatureDemo.java">
    <y:displayname>VisualFeatureDemo</y:displayname>
    <y:summary>
      Presents the visual features that are available with node realizers and edge realizers.
      In particular, these include labels for both nodes and edges, decorations for edge
      end points, but also colors and shapes for both types of graph elements.
    </y:summary>
    <y:description>
      Demonstrates visual features and editor behaviour
      <ol>
      <li>EdgeLabels that display icons and text<br/>
              </li>
      <li>Rotated Labels<br/>
              </li>
      <li>Auto rotating EdgeLabels
      <br/>
              </li>
      <li>Transparent colors
      <br/>
              </li>
      <li>Gradients
      <br/>
              </li>
      <li>Bridges for crossing PolyLine Edges
      <br/>
              </li>
      <li>InterfacePorts that display icons. (A port defines the logical and visual endpoint of and edge path)
      <br/>
              </li>
      <li>In edit mode you can reposition an edge label by pressing on it with the left mouse button and then by dragging
      the label around. Possible label candidate boxes will appear along the edge. If you release the mouse button again,
      the label will snap to the closest of the candidate boxes.
      <br/>
              </li>
      <li>In edit mode you can interactively change the offsets of edge ports. Select the edge that should have different
      ports. A little black dot will appear at the point where the port has it's logical location. You can drag the black
      dot around. By doing so, port candidate boxes will appear around the connected node. If you release the mouse again
      the port will snap to the closest available port candidate position.
      <br/>
              </li>
      <li>In edit mode you can create an edge that has non-zero port offsets by starting edge creation with the shift key
      pressed down. The point where you press will become the source port location of the edge. If you have the shift key
      down when you finish edge creation (by releasing the mouse over a node) that the release point will become the offset
      of the target port of the edge.
      <br/>
              </li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>image</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>decoration</y:keyword>
      <y:keyword>color</y:keyword>
      <y:keyword>shape</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.GenericNodeRealizerDemo" source="GenericNodeRealizerDemo.java">
    <y:displayname>GenericNodeRealizerDemo</y:displayname>
    <y:description>
      This class demonstrates the usage of the <code>y.view.GenericNodeRealizer</code>
      class which makes it easy to provide customized node rendering.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>GenericNodeRealizer</y:keyword>
      <y:keyword>configuration</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.GenericEdgeRealizerDemo" source="GenericEdgeRealizerDemo.java">
    <y:displayname>GenericEdgeRealizerDemo</y:displayname>
    <y:summary>
      This class demonstrates the usage of the <code>y.view.GenericEdgeRealizer</code>
      class which makes it easy to provide customized edge rendering.
    </y:summary>
    <y:description>
      <p>
      This class demonstrates the usage of the <code>y.view.GenericEdgeRealizer</code>
      class which makes it easy to provide customized edge rendering.
      </p>
      <p>
      <b>Usage:</b> Try adding new edges and adding bends to existing edges.
      The combo box in the toolbar allows to switch between the possible edge
      types for creating new edges.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>GenericEdgeRealizer</y:keyword>
      <y:keyword>configuration</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.YLabelConfigurationDemo" source="YLabelConfigurationDemo.java">
    <y:displayname>YLabelConfigurationDemo</y:displayname>
    <y:description>
      This class demonstrates the usage of YLabel's configuration feature which simplifies
      customized label rendering.
      <br/>
      Things to try: move nodes around, move node/edge labels around, select a node/edge
      and press F2 to edit the label, insert/move bends of edges.
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>YLabel</y:keyword>
      <y:keyword>cropping</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.TableStyleDemo" source="TableStyleDemo.java">
    <y:displayname>TableStyleDemo</y:displayname>
    <y:description>
      Demonstrates different visual styles for table groups and their content.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>TableGroupNodeRealizer</y:keyword>
      <y:keyword>TableNodePainter</y:keyword>
      <y:keyword>TableStyle</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.SwingRendererDemo" source="SwingRendererDemo.java">
    <y:displayname>SwingRendererDemo</y:displayname>
    <y:description>
      This class shows how to customize GenericNodeRealizer to display JComponents as nodes.
    </y:description>
    <y:keywords>
      <y:keyword>Swing</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>JComponent</y:keyword>
      <y:keyword>GenericNodeRealizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.UMLClassNodeRealizer" source="UMLClassNodeRealizer.java">
    <y:displayname>UMLClassNodeRealizer</y:displayname>
    <y:description>
      This class represents a custom NodeRealizer that can be used to
      represent a class in an UML diagram. It supports classname, sterotype,
      constraint, attribute list, and method list.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>class</y:keyword>
      <y:keyword>UML</y:keyword>
      <y:keyword>classname</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.BridgeEdgeRealizerDemo" source="BridgeEdgeRealizerDemo.java">
    <y:displayname>BridgeEdgeRealizerDemo</y:displayname>
    <y:description>
      This class demonstrates how to implement a custom EdgeRealizer that shows
      bridges/gaps when crossing other edges.
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>bridge</y:keyword>
      <y:keyword>gap</y:keyword>
      <y:keyword>crossing</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.StateNodeRealizer" source="StateNodeRealizer.java" executable="false">
    <y:displayname>StateNodeRealizer</y:displayname>
    <y:summary>
      This demo shows how the custom node realizer <code>StateNodeRealizer</code>
      can be used within an application.
    </y:summary>
    <y:description>
      This demo shows how the custom node realizer <code>StateNodeRealizer</code>
      can be used within an application.
      <br/>
      The demo allows to create nodes that have different state.
      Additionally it is possible to change the state of a node by right clicking
      on it.
      A graph with its custom node realizers can be saved and loaded using the GraphML
      format.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>paint</y:keyword>
      <y:keyword>customization</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.StateNodeRealizerDemo" source="StateNodeRealizerDemo.java">
    <y:displayname>StateNodeRealizerDemo</y:displayname>
    <y:description>
      This demo shows how the custom node realizer <a href="StateNodeRealizer.java">
      StateNodeRealizer</a> can be used within an application.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>paint</y:keyword>
      <y:keyword>customization</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.ScrollingNodeRealizer" source="ScrollingNodeRealizer.java">
    <y:displayname>ScrollingNodeRealizer</y:displayname>
    <y:description>
      Demonstrates how scrollbars inside a NodeRealizer can be implemented.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>scrolling</y:keyword>
      <y:keyword>customization</y:keyword>
      <y:keyword>scrollbar</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.hierarchy">
  <y:displayname>Nested Graphs</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Hierarchy Demos</h1>
    <p>
    The following tutorial view demos show how to work with hierarchically structured
    graphs.
    </p>
  </y:description>

  <y:demo javaname="demo.view.hierarchy.HierarchyDemo" source="HierarchyDemo.java">
    <y:displayname>HierarchyDemo</y:displayname>
    <y:summary>
      Exhibits the <b>Nested Graph Hierarchy</b> and the <b>Node Grouping</b>
      technologies that are a modular part of the yFiles library.
    </y:summary>
    <y:description>
      <p>
        This tutorial source code demo
        exhibits
        the
        <b>Nested Graph Hierarchy</b>
        and the
        <b>Node Grouping</b>
        technologies
        that are a modular part of the yFiles library.
      </p>

      <h2>Nested Graph Hierarchy</h2>

      <p>
        <b>Nested Graph Hierarchy</b>
        basically provides the possibility to
        put a graph inside a node which itself is contained in another
        graph.
        A node that contains another graph is called an
        <b>anchor node</b>
        or a
        <b>folder node</b>
        A tree-like hierarchy of graphs will be induced by a nesting
        of graphs inside of other nodes. The top-level graph of this hierarchy
        of graphs is called the
        <b>root graph</b>
        . A graph that
        contains a nested graph is called the
        <b>parent graph</b>
        of
        that nested graph.
      </p>

      <h2>Node Grouping/Nesting</h2>
      <p>
        <b>Node Grouping</b>
        complements the
        <i>Nested Graph Hierarchy</i>
        technology. It is a feature mainly provided by the viewer component. Nodes
        of all kind can be put together in a group, that will be visualized by a
        group node, which will be painted in the background of it's child nodes.
        In contrast to the
        <i>Nested Graph Hierarchy</i>
        technology, all nodes,
        <i>group nodes</i>
        and their
        <i>child nodes</i>
        reside in the top level
        graph at the same time. However the view suggests that at all times, child
        nodes lie within their respective parent group nodes. This makes it possible
        to connect nodes of different logical hierarchy levels with each other
        visually.
      </p>

      <p>
        This application demonstrates the use of these two technologies. Since both
        of them can be used to describe a hierarchy of nodes, it is possible to
        simply switch between the two different technologies. The actions that are
        made accessible through this application can be used to edit the graph/node
        hierarchy and the visual presentation of the hierarchy.
      </p>

      <center>
        <table>
          <caption align="bottom">A hierarchical graph with
            folder nodes, that contain graphs themselves.
          </caption>
          <tr>
            <td>
              <img src="resource/hierarchy1.jpg" alt="Sample Image"/>
            </td>
          </tr>
        </table>
      </center>

      <p>
        A noteworthy feature of the yFiles
        <b>Nested Graph Hierarchy</b>
        is
        that one can move parts of a graph to another level within the
        hierarchy of graphs. The edges connecting the part that has
        been moved with the rest of the graph won't get lost though.
        Original edges will be represented by edges connecting to the
        node the subgraph is nested in. When unpacking the contents of a
        node again, the original edges will be restored. Hence the
        topology of a graph won't be destroyed by a sequence of
        nesting operations.
      </p>

      <h2>Using HierarchyDemo</h2>

      <p>
        HierarchyDemo displays three views of a nested graph hierarchy.
        On the left there is a classic tree view that shows the complete
        graph hierarchy and all of the nodes contained within it.
        The main view of HierarchyDemo displays the graph hierarchy
        from a specific hierarchy level on downward.
        The graphs that are nested within folder-nodes are displayed
        as well. Group nodes look similar to folder-nodes but behave differently.
        While it is possible to resize and move folder-nodes freely, the position
        and size of a group-node is induced by the positions and sizes of the child
        nodes that belong to the respective group. While a folder-node only
        displays the child nodes it contains, the children of a group node still belong
        to the graph structure and can be treated like normal nodes.
        The third view of HierarchyDemo is located above the tree view.
        It acts as an overview display of the graph that is visualized in
        the main view.
      </p>

      <h2>The Main view</h2>

      <p>
        This section describes which hierarchy-related and grouping-related
        operations are available within the main view.
      </p>

      <h3>The Popup Menu</h3>

      <p>
        By right clicking on the main view a popup menu will become
        visible. The following menu items manipulate the graph hierarchy
        or the view on the graph hierarchy:
      </p>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>

        <tr>
          <td>Group Selection</td>
          <td>
            Selected nodes will be grouped. This is done by creating a new group
            node and making the selected nodes logically children of the newly
            created group node. If no nodes are selected, an empty group node will
            be created.
          </td>
        </tr>
        <tr>
          <td>Ungroup Selection</td>
          <td>
            Selected nodes will be ungrouped, i.e. they will become child nodes of the
            parent of their current parent node. Empty group nodes will not be
            removed, but stay in the graph structure.
          </td>
        </tr>

        <tr>
          <td>Close Group</td>
          <td>
            This action can be invoked on selected group nodes. This will actually
            switch the node from
            <i>Node Grouping</i>
            technology to
            <i>Nested
              Graph
            </i>
            technology. This can be undone by invoking
            <i>Open
              Folder
            </i>
            on the closed group node.
          </td>
        </tr>

        <tr>
          <td>Create Folder</td>
          <td>
            Creates a new folder node containing an empty graph.
          </td>
        </tr>
        <tr>
          <td>Fold Selection</td>
          <td>
            This method folds the subgraph induced by the selected
            nodes inside a newly created folder node.
          </td>
        </tr>
        <tr>
          <td>Unfold Selection</td>
          <td>
            This method moves the subgraph induced by the selected
            nodes to the parent graph. This operation is only available
            if the graph displayed in the main view is not the root
            graph. Otherwise there would be no parent graph to unfold
            the selection to.
          </td>
        </tr>
        <tr>
          <td>Extract Folder</td>
          <td>
            Extract the contents of the folder-node on which the
            popup menu has been opened upon and remove the then
            empty folder.
          </td>
        </tr>
        <tr>
          <td>Open Folder</td>
          <td>
            Opens the currently selected folder-node, thus transforming it
            into a group-node. This is the reverse operation of
            <i>Close
              Group
            </i>
            .
          </td>
        </tr>
      </table>

      <h3>The Menu Bar</h3>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            <a name="view_parent"/>
            Toolbar - View Parent
          </td>
          <td>
            View the parent graph of the currently display graph in
            the main view. This operation is only available
            if the graph displayed in the main view is not the root
            graph. Otherwise there would be no parent graph to unfold
            the selection to.
          </td>
        </tr>
        <tr>
          <td>Tools - Unfold All</td>
          <td>
            This method recursively unfolds the contents of all
            folder nodes within the displayed graph.
          </td>
        </tr>
        <tr>
          <td>Tools - Fold Selection</td>
          <td>
            Creates for each connected component of the displayed graph
            a new folder-node. Each connected component will be moved
            from the displayed graph to the corresponding folder-node.
          </td>
        </tr>
        <tr>
          <td>Tools - Fold Subtrees</td>
          <td>
            This method finds tree-structures that are part of the
            displayed graph. For each of these trees a new
            folder-node will be created. Each tree will be
            moved from the displayed graph to the corresponding folder node.
            Each nested tree will be automatically layed out using
            ballon layouter. The size-ratio of the folder-nodes will be
            automatically adjusted to the size of the nested trees.
            <br/>
            Please note that the code to automatically layout the subgraphs
            is commented out by default in order to make this demo compile even if
            only the yFiles viewer package is available.
            Uncomment the code lines if the layout package is available to
            activate the layouter.
          </td>
        </tr>
      </table>

      <h3>Hierarchic View Mode</h3>

      <p>
        There are some additional hierarchy-related operations
        available on the main view that are triggered by mouse gestures.
      </p>

      <ul>
        <li>
          Dropping a selection of nodes onto a group-node while pressing the
          "shift" modifier key
          will make the selected nodes part of the group that is visualized by
          the group-node.
          The location of the mouse cursor must be on a group-node
          when the mouse button gets released.
        </li>
        <li>
          Pressing the "shift" modifier key before starting to drag a selection of
          nodes will ungroup the selected nodes.
        </li>
        <li>
          Double-clicking on a folder-node navigates into the folder.
        </li>
      </ul>

      <h2>The Tree View</h2>

      <p>
        Double-clicking on a node that is displayed
        in the tree view transfers the focus of the main view
        to that node.
        Focusing a node in the main view involves two things:
        The nested graph that contains the focused node gets
        displayed in the main view. And the focused node will
        be displayed in the center of the view.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.CustomGroupVisualizationDemo" source="CustomGroupVisualizationDemo.java">
    <y:displayname>CustomGroupVisualizationDemo</y:displayname>
    <y:summary>
      Demonstrates how to customize the visual representation of group and folder
      nodes using <code>y.view.hierarchy.GenericGroupNodeRealizer</code>.
    </y:summary>
    <y:description>
      Demonstrates how to customize the visual representation of group and folder
      nodes using <code>y.view.hierarchy.GenericGroupNodeRealizer</code>.
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>generic</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.GroupingDemo" source="GroupingDemo.java">
    <y:displayname>GroupingDemo</y:displayname>
    <y:summary>
      Exhibits the <b>Nested Graph Hierarchy</b> and the <b>Node Grouping</b> technologies
      that are a modular part of the yFiles library.
    </y:summary>
    <y:description>
      <p>
        This tutorial source code demo
        exhibits
        the
        <b>Nested Graph Hierarchy</b>
        and the
        <b>Node Grouping</b>
        technologies
        that are a modular part of the yFiles library.
      </p>

      <h2>Nested Graph Hierarchy</h2>

      <p>
        <b>Nested Graph Hierarchy</b>
        basically provides the possibility to
        put a graph inside a node which itself is contained in another
        graph.
        A node that contains another graph is called an
        <b>anchor node</b>
        or a
        <b>folder node</b>
        A tree-like hierarchy of graphs will be induced by a nesting
        of graphs inside of other nodes. The top-level graph of this hierarchy
        of graphs is called the
        <b>root graph</b>
        . A graph that
        contains a nested graph is called the
        <b>parent graph</b>
        of
        that nested graph.
      </p>

      <h2>Node Grouping/Nesting</h2>
      <p>
        <b>Node Grouping</b>
        complements the
        <i>Nested Graph Hierarchy</i>
        technology. It is a feature mainly provided by the viewer component. Nodes
        of all kind can be put together in a group, that will be visualized by a
        group node, which will be painted in the background of it's child nodes.
        In contrast to the
        <i>Nested Graph Hierarchy</i>
        technology, all nodes,
        <i>group nodes</i>
        and their
        <i>child nodes</i>
        reside in the top level
        graph at the same time. However the view suggests that at all times, child
        nodes lie within their respective parent group nodes. This makes it possible
        to connect nodes of different logical hierarchy levels with each other
        visually.
      </p>

      <p>
        This application demonstrates the use of these two technologies. Since both
        of them can be used to describe a hierarchy of nodes, it is possible to
        simply switch between the two different technologies. The actions that are
        made accessible through this application can be used to edit the graph/node
        hierarchy and the visual presentation of the hierarchy.
      </p>

      <center>
        <table>
          <caption align="bottom">A hierarchical graph with
            folder nodes, that contain graphs themselves.
          </caption>
          <tr>
            <td>
              <img src="resource/hierarchy1.jpg" alt="Sample Image"/>
            </td>
          </tr>
        </table>
      </center>

      <p>
        A noteworthy feature of the yFiles
        <b>Nested Graph Hierarchy</b>
        is
        that one can move parts of a graph to another level within the
        hierarchy of graphs. The edges connecting the part that has
        been moved with the rest of the graph won't get lost though.
        Original edges will be represented by edges connecting to the
        node the subgraph is nested in. When unpacking the contents of a
        node again, the original edges will be restored. Hence the
        topology of a graph won't be destroyed by a sequence of
        nesting operations.
      </p>

      <h2>Using GroupingDemo</h2>

      <p>
        GroupingDemo displays a view of a nested graph hierarchy.
        Group nodes look similar to folder-nodes but behave differently.
        While it is possible to resize and move folder-nodes freely, the position
        and size of a group-node is induced by the positions and sizes of the child
        nodes that belong to the respective group. While a folder-node only
        displays the child nodes it contains, the children of a group node still belong
        to the graph structure and can be treated like normal nodes.
      </p>

      <h2>Available actions</h2>

      <p>
        This section describes which hierarchy-related and grouping-related
        operations are available within the view.
      </p>

      <h3>The Popup Menu and the Grouping Menu</h3>

      <p>
        By right clicking on the main view a popup menu will become
        visible. The Grouping menu on the applications menu bar provides the same actions.
        The following menu items manipulate the graph hierarchy
        or the view on the graph hierarchy:
      </p>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>Close Group</td>
          <td>
            This action can be invoked on selected group nodes. This will actually
            switch the node from
            <i>Node Grouping</i>
            technology to
            <i>Nested
              Graph
            </i>
            technology. This can be undone by invoking
            <i>Open
              Folder
            </i>
            on the closed group node.
          </td>
        </tr>
        <tr>
          <td>Open Folder</td>
          <td>
            Opens the currently selected folder-node, thus transforming it
            into a group-node. This is the reverse operation of
            <i>Close Group</i>
            .
          </td>
        </tr>
        <tr>
          <td>Group Selection</td>
          <td>
            Selected nodes will be grouped. This is done by creating a new group
            node and making the selected nodes logically children of the newly
            created group node.
          </td>
        </tr>
        <tr>
          <td>Ungroup Selection</td>
          <td>
            Selected nodes will be ungrouped, i.e. they will become child nodes of the
            parent of their current parent node. Empty group nodes will not be
            removed, but stay in the graph structure.
          </td>
        </tr>
        <tr>
          <td>Fold Selection</td>
          <td>
            This method folds the subgraph induced by the selected
            nodes inside a newly created folder node.
          </td>
        </tr>
      </table>


      <h3>Hierarchic View Mode</h3>

      <p>
        There are some additional hierarchy-related operations
        available on the main view that are triggered by mouse gestures.
      </p>

      <ul>
        <li>
          Dropping a selection of nodes onto a group-node while pressing the
          "shift" modifier key
          will make the selected nodes part of the group that is visualized by
          the group-node.
          The location of the mouse cursor must be on a group-node
          when the mouse button gets released.
        </li>
        <li>
          Pressing the "shift" modifier key before starting to drag a selection of
          nodes will ungroup the selected nodes.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.GroupNavigationDemo" source="GroupNavigationDemo.java">
    <y:displayname>GroupNavigationDemo</y:displayname>
    <y:summary>
      This demo extends
      <code>GroupingDemo</code>
      to show how to implement custom navigation actions to navigate to group/folder node contents and back.
    </y:summary>
    <y:description>
      The following actions are supported:
      <ul>
        <li>Navigation into a group or folder node: Either select a single group or folder node and press <code>CTRL+PAGE_DOWN</code>, or
        use the entry "Enter Group" in the node's context menu. This will change the view graph to the inner graph of the folder or group node.
        If the node to enter is not a group or folder node, nothing happens.</li>
        <li>Navigation to the parent graph: Either press <code>CTRL+PAGE_UP</code>, or
        use the entry "Navigate to parent" in the context menu. This will change the view graph to the parent graph of the folder or group node. If
        the view is already at root level, nothing is done.</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.HierarchyJTreeDemo" source="HierarchyJTreeDemo.java">
    <y:displayname>HierarchyJTreeDemo</y:displayname>
    <y:summary>
      This demo extends
      <code>GroupingDemo</code>
      to show how to use class
      <code>y.view.hierarchy.HierarchyJTree</code>
      to display the hierarchical structure as a <code>JTree</code>.
     </y:summary>
      <y:description>
      <code>HierarchyJTree</code>
      provides a different view on the graph structure, as well as (optionally) navigational actions
      and support for changes in the hierarchical structure. This demo provides the following actions:
        <ul>
          <li>Double clicking on a node in the tree centers the view on this node. If the node is contained in a folder node,
          this action navigates to the inner graph of the node's parent folder.</li>
          <li>Drag/drop inside the tree changes the graph hierarchy.</li>
          <li>Editing labels in the tree will change the actual node labels and vice versa.</li>
        </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.advanced">
  <y:displayname>Advanced</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:description>
    <h1>Advanced yFiles Tutorial View Demos</h1>
    <p>
    The following tutorial view demos show how to use advanced application
    features like inactive graph layers, graph models with many views, nodes with fixed ports,
    and edges connecting at other edges.
    </p>

    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="ports/README.html">demo.view.advanced.ports</a>
        </td>
        <td>
          Contains demos that focus on yFiles' node ports. These demos
          demonstrate how to use and interact with node ports as well as how to
          customize their visual appearance and how to associate labels to node
          ports.
        </td>
      </tr>
    </table>
  </y:description>

  <y:demo javaname="demo.view.advanced.EdgeConnectorDemo" source="EdgeConnectorDemo.java">
    <y:displayname>EdgeConnectorDemo</y:displayname>
    <y:summary>
      Shows how to mimic node-to-edge and edge-to-edge connection.
    </y:summary>
    <y:description>
      <p>
      Shows how to mimic node-to-edge and edge-to-edge connection.
      In this demo an edge that connects to a node or to another edge is
      modeled as a normal edge that has a special node as its end point.
      That special node is located on the path of the edge. When moving
      the edge path the special node will also be moved. Thus, it looks
      and feels like a proper edge connection to an edge.
      </p>
      <p>
      <b>Usage:</b> to create an edge that starts at another edge, shift-press
      on the edge to initiate the edge creation gesture, then drag the mouse.
      To create an edge that ends at another edge, shift-release the mouse on
      the edge.
 	  </p>
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>connection</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.InactiveLayerDemo" source="InactiveLayerDemo.java">
    <y:displayname>InactiveLayerDemo</y:displayname>
    <y:summary>
      Demonstrates how to put a part of a graph in an inactive background layer of the view.
    </y:summary>
    <y:description>
      <p>
      Demonstrates how to put a part of a graph in an inactive background
      layer of the view.
      </p>
      <p>
      <b>Usage:</b> when parts of the graph are selected, then a right mouse
      click brings up a menu that offers to put the selected part of the graph
      to the inactive background. If none is selected then a right mouse click
      brings up a popup menu that allows to bring the inactive graph part back
      to life.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>background</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>inactive</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.ModelViewManagerDemo" source="ModelViewManagerDemo.java">
    <y:displayname>ModelViewManagerDemo</y:displayname>
    <y:summary>
      Demonstrates automatic structural synchronization between several graphs using y.view.ModelViewManager.
    </y:summary>
    <y:description>
      <p>
      Demonstrates automatic structural synchronization between several graphs
      using y.view.ModelViewManager.
      </p>
      <p>
      The demo shows four different Graph2DViews in a 2-by-2 matrix. The top-left one
      presents the model graph, the latter three ones show derived views of this model
      graph.
      <br/>
      Each of the derived views has special characteristics: for example, the bottom-left
      one does not show any of the edges from the model graph, the bottom-right one
      is empty at first and only shows nodes created interactively by a user.
      Also, in some views the visual representation of the nodes differs from the model
      graph.
      </p>
      <p>
      In all views there can be applied an automatic layout to the contained graph.
      Additionally, the two views at the bottom, which prevent editing of their contained
      graphs, provide a button to synchronize their contents back to the model graph's
      view, which in turn updates the other derived views.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>model</y:keyword>
      <y:keyword>view</y:keyword>
      <y:keyword>satellite</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>relation</y:keyword>
      <y:keyword>synchronization</y:keyword>
    </y:keywords>
  </y:demo>
<y:package javaname="demo.view.advanced.ports">
  <y:displayname>Ports</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:description>
    <h1>The following demos demonstrate how to use and interact with node ports
        as well as how to customize their visual appearance and how to associate
        labels to node ports.</h1>
  </y:description>

  <y:demo javaname="demo.view.advanced.ports.NodePortsDemo" source="NodePortsDemo.java">
    <y:displayname>NodePortsDemo</y:displayname>
    <y:summary>
        Demonstrates how to use node ports.
    </y:summary>
    <y:description>
      Demonstrates how to use node ports.
      <h3>Working with node ports</h3>
      <dl>
        <dt>Adding ports to a node</dt>
        <dd>
          Right-click on a node to open the context menu. A port can be added to the
          node by choosing one of the displayed prototypes.
        </dd>

        <dt>Selecting ports</dt>
        <dd>
          A port can be selected by left-clicking on the port.
          If one or more ports are already selected, the selection box can be used
          to select additional ports and pressing <code>CONTROL+A</code> will
          select all ports.
        </dd>

        <dt>Moving ports</dt>
        <dd>
          A port can be moved by first selecting it and then dragging it with the
          mouse.
        </dd>

        <dt>Displaying context menus</dt>
        <dd>
          Context menus for nodes and ports are displayed by right-clicking on the
          corresponding element.
        </dd>

        <dt>Removing ports from a node</dt>
        <dd>
          Selected ports can be removed using the <code>DELETE</code> key, the
          corresponding icon in the tool bar, or the corresponding entry in the
          port context menu.
        </dd>

        <dt>Connecting edges to ports</dt>
        <dd>
          An edge can be connected to a port by dragging the mouse from a port or
          node that is not selected to another port or node that has ports.
        </dd>

        <dt>Adding labels to ports</dt>
        <dd>
          A label can be add to a port by choosing <code>Add Label</code> from the
          port context menu.
        </dd>
      </dl>

      <h3>Miscellaneous</h3>
      <dl>
        <dt>Laying out nodes and edges</dt>
        <dd>
          A new layout for the graph is calculated by pressing the
          <code>Layout Graph</code> button in the tool bar.
          <br/>
          If <code>Group Edges</code> is selected, edges that connect to the same
          port may overlap each other.
          <br/>
          (This feature is not available in the yFiles View distribution.)
        </dd>

        <dt>Routing edges</dt>
        <dd>
          A new layout for the edges of the graph is calculated by pressing the
          <code>Route Edges</code> button in the tool bar. Nodes will not be moved.
          <br/>
          If <code>Group Edges</code> is selected, edges that connect to the same
          port may overlap each other.
          <br/>
          (This feature is not available in the yFiles View distribution.)
        </dd>

        <dt>Grouping nodes</dt>
        <dd>
          Use <code>CONTROL+ALT+G</code> to create a common parent group node for
          selected nodes.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>port</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.ports.LogicGatesDemo" source="LogicGatesDemo.java">
    <y:displayname>LogicGatesDemo</y:displayname>
    <y:description>
    Demonstrates how to create an application that makes use of nodes that have a fixed set of ports.
    The nodes represent logic gates. Edges can only start at the ports located at the right side of nodes.
    These are the outputs of the represented gates. Edges can only end at ports located at the left side
    of the nodes. These are the inputs of the represented gates. Valid ports will be highlighted when
    hovering over a node or when creating an edge. The nodes are realized using GenericNodeRealizers and the
    ports are realized using NodePorts.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>port</y:keyword>
      <y:keyword>fixed</y:keyword>
    </y:keywords>
  </y:demo>  
</y:package>
      </y:package>
      <y:package javaname="demo.view.viewmode">
  <y:displayname>User Interaction</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial ViewMode Demos</h1>
    <p>
      The following tutorial demos describe how to use, customize, and extend
      diverse ViewMode classes. View modes provide the base functionality to handle
      mouse-based interaction that happens in a view.
    </p>
  </y:description>

  <y:demo javaname="demo.view.viewmode.MagnifierViewModeDemo" source="MagnifierViewModeDemo.java">
    <y:displayname>MagnifierViewModeDemo</y:displayname>
    <y:summary>
      Demonstrates how to use a magnifying glass effect to zoom view regions locally.
    </y:summary>
    <y:description>
      <p>
      Demonstrates how to use a magnifying glass effect to zoom view regions locally.
      </p>
      <p>
      <b>Usage:</b> to activate the magnifier select the "Use Magnifier" button. Move the mouse
      over the view canvas to move the magnifier. Note that you can even edit the graph
      while the magnifier is active. Use the mouse wheel to change the zoom factor of the
      magnifier. To change the radius of the magnifier with the mouse wheel, additionally
      keep the CTRL key pressed. To deactivate the magnifier again, deselect the
      "Use Magnifier" button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>magnify</y:keyword>
      <y:keyword>magnifying</y:keyword>
      <y:keyword>glass</y:keyword>
      <y:keyword>tool</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>region</y:keyword>
      <y:keyword>local</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.FullScreenNavigationDemo" source="FullScreenNavigationDemo.java">
    <y:displayname>FullScreenNavigationDemo</y:displayname>
    <y:description>
      This demo demonstrates the usage of y.view.NavigationComponent and y.view.Overview. Both controls
      will be added to a glass pane the view provides (y.view.Graph2DView#getGlassPane()) and can be toggled during
      runtime.
      <br/>
      Besides one can switch to a full screen mode and navigate through the graph view.
    </y:description>
    <y:keywords>
      <y:keyword>full-screen</y:keyword>
      <y:keyword>full</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>screen</y:keyword>
      <y:keyword>NavigationComponent</y:keyword>
      <y:keyword>control</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.OrthogonalEdgeViewModeDemo" source="OrthogonalEdgeViewModeDemo.java">
    <y:displayname>OrthogonalEdgeViewModeDemo</y:displayname>
    <y:description>Demonstrates how to customize EditMode in order to simulate orthogonal edges.
      <br/>
      This demo allows to switch between the creation of orthogonal and polygonal edges and toggling snapping behavior
      on and off.
      Toggling the "Orthogonal" button in the toolbar switches the type of newly created edges.
      Also intelligent snapping for the various view modes can be toggled in the tool bar.
      This affects the behavior of CreateEdgeMode and EditMode, as well as implicitly the minor modes
      of EditMode.
    </y:description>
    <y:keywords>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>orthogonal</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>path</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>snapping</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.SnapLineDemo" source="SnapLineDemo.java">
    <y:displayname>SnapLineDemo</y:displayname>
    <y:description>Demonstrates EditMode's snapping feature in conjunction with orthogonal edges.
      <br/>
      This demo can be used to toggle the snapping feature on and off. It shows how a custom <b>SnapLine</b>
      (the red vertical line) can be used to snap nodes and edges to other entities.
      Toggling the button in the toolbar toggles snapping on and off, the sliders can be used to adjust the
      preferred distance between nodes and edges. This will influence the "preferred distance snap lines."
    </y:description>
    <y:keywords>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>SnapLine</y:keyword>
      <y:keyword>snapping</y:keyword>
      <y:keyword>EditMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.RollOverEffectDemo" source="RollOverEffectDemo.java">
    <y:displayname>RollOverEffectDemo</y:displayname>
    <y:description>
      Demonstrates how to create a custom ViewMode that uses yFiles'
      Animation Framework to produce a roll over effect for nodes under the mouse
      cursor.
    </y:description>
    <y:keywords>
      <y:keyword>roll-over</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>node</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.MouseInputDemo" source="MouseInputDemo.java">
    <y:displayname>MouseInputDemo</y:displayname>
    <y:summary>
      Demonstrates how to add a custom drawable to the view that interacts
      with the MouseInputMode that is registered with class EditMode by default.
    </y:summary>
    <y:description>
      <p>
      Demonstrates how to add a custom drawable to the view that interacts
      with the MouseInputMode that is registered with class EditMode by default.
      </p>
      <p>
      <b>Usage:</b> Move the mouse over one af the arrows in the upper left
      corner of the view and press it to move the view port in the indicated
      direction.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>MouseInputMode</y:keyword>
      <y:keyword>interaction</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.PopupModeDemo" source="PopupModeDemo.java">
    <y:displayname>PopupModeDemo</y:displayname>
    <y:summary>
      Demonstrates how to display context sensitive popup menus
      and how to edit node labels in the view.
    </y:summary>
    <y:description>
      Demonstrates how to display context sensitive popup menus
      in the view.
      <br/>
      This demo does also show how to write an action that opens
      an inlined text editor in the view to modify the label of a node.
      <br/>
      To activate the popup menus right click either on a node, an edge, or
      the view background.
    </y:description>
    <y:keywords>
      <y:keyword>context</y:keyword>
      <y:keyword>context-sensitive</y:keyword>
      <y:keyword>popup</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>editor</y:keyword>
      <y:keyword>PopupMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.CreateEdgeModeDemo" source="CreateEdgeModeDemo.java">
    <y:displayname>CreateEdgeModeDemo</y:displayname>
    <y:summary>
      Demonstrates how CreateEdgeMode can be customized to prevent
      the creation of certain edges and to provide feedback whether
      creating an edge to the node the mouse is hovering over is possible.
    </y:summary>
    <y:description>
      Demonstrates how CreateEdgeMode can be customized to prevent
      the creation of certain edges and to provide feedback whether
      creating an edge to the node the mouse is hovering over is possible.
      <br/>
      This demo does only allow the creation of edges that start with nodes
      that have an even numbered label and
      end with nodes that have uneven numbered labels.
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>creation</y:keyword>
      <y:keyword>odd</y:keyword>
      <y:keyword>even</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>prevent</y:keyword>
      <y:keyword>allow</y:keyword>
      <y:keyword>disallow</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.PortCreateEdgeModeDemo" source="PortCreateEdgeModeDemo.java">
    <y:displayname>PortCreateEdgeModeDemo</y:displayname>
    <y:summary>
      Demonstrates how CreateEdgeMode can be customized in order to
      control automatic assignments of ports for edges.
    </y:summary>
    <y:description>
      <p>
      Demonstrates how CreateEdgeMode can be customized in order to
      control automatic assignments of ports for edges.
      <br/>
      Edges are created in such a way, that the source port is always on
      the top side of the source node and the target port is always on the bottom
      side of the target node.
      </p>
      <p>
      <b>Usage:</b> Create some nodes and edges. Select an edge to check its
      source and target ports.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>creation</y:keyword>
      <y:keyword>port</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.application">
  <y:displayname>Sample: Flowchart</y:displayname>
  <y:displaypriority>15</y:displaypriority>
  <y:description>
  <h1>The Flowchart demo</h1>
  This demo allows to visualize and edit the flowchart diagrams. An integrated palette provides flowchart symbols
  for creation of diagrams.
  From the viewpoint of programming, this demo shows many aspects. In particular it shows how to
  <ul>
      <li>integrate and configure a customized <code>y.view.Graph2DView</code> into your Swing application</li>
      <li>implement a default flowchart palette</li>
      <li>implement a custom node painter for drawing of flowchart symbols</li>
  </ul>
  </y:description>

  <y:demo javaname="demo.view.flowchart.FlowchartDemo" source="FlowchartDemo.java">
    <y:displayname>FlowchartDemo</y:displayname>
    <y:summary>The main demo program in this tutorial.</y:summary>
    <y:description>
        This demo allows to visualize and edit the flowchart diagrams. An integrated palette provides flowchart symbols
        for creation of diagrams.
        From the viewpoint of programming, this demo shows many aspects. In particular it shows how to
        <ul>
            <li>integrate and configure a customized <code>y.view.Graph2DView</code> into your Swing application </li>
            <li>implement a default flowchart palette.</li>
            <li>implement a custom node painter for drawing of flowchart symbols. For details please see the package: <code>demo.view.flowchart.painters</code>
              </li>
        </ul>
    </y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.flowchart.FlowchartPalette" source="FlowchartPalette.java" executable="false">
    <y:displayname>FlowchartPalette</y:displayname>
    <y:description>This is a component, which represents a palette of flowchart nodes or edges and allows to drag them into a <code>y.view.Graph2DView</code>.</y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.flowchart.FlowchartView" source="FlowchartView.java" executable="false">
    <y:displayname>FlowchartView</y:displayname>
    <y:description>For flowchart adjusted <code>y.view.Graph2DView</code> </y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
    </y:package>
    <y:package javaname="demo.option">
  <y:displayname>UI Property Grid</y:displayname>
  <y:description>
<h1>yFiles Tutorial OptionHandler Demos</h1>
<p>
The following source code samples show how to use the features
of the yFiles y.option package. Package y.option provides means to 
quickly create property editors for items of diverse types.
</p>
</y:description>

  <y:demo javaname="demo.option.NodePropertyEditorDemo" source="NodePropertyEditorDemo.java">
    <y:displayname>NodePropertyEditorDemo</y:displayname>
    <y:summary>
      Demonstrates how to create a node property editor for nodes.
    </y:summary>
    <y:description>
      <p>
        Demonstrates how to create a node property editor for nodes.
        This demo makes use of the "value-undefined" state of option items.
      </p>
      <p>
        A node property editor can either be displayed for a single node
        by double-clicking on the node or for multiple nodes by first
        selecting the nodes and then clicking on the "Edit Node Properties"
        toolbar button.
      </p>
      <p>
        The property editor will be initialized by the current settings
        of the selected nodes. If the value of a specific property differs for two
        selected nodes the editor will display the value as undefined.
        Upon closing the editor dialog, only well-defined values will be
        committed to the selected nodes.
      </p>
    </y:description>
  <y:keywords>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>valueUndefined</y:keyword>
<y:keyword>value</y:keyword>
<y:keyword>undefined</y:keyword>
<y:keyword>Selections</y:keyword>
<y:keyword>SelectionStateObserver</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.option.OptionHandlerDemo" source="OptionHandlerDemo.java">
    <y:displayname>OptionHandlerDemo</y:displayname>
    <y:summary>
      Demonstrates how to create an OptionHandler whose values are
      editable by multiple editor components.
    </y:summary>
    <y:description>
      Demonstrates how to create an OptionHandler whose values are
      editable by multiple editor components. The demo also shows
      how to localize and customize these editors, and how to register listeners
      for <code>PropertyChange</code> events.
      <br/>
      <br/>
      Usage Note:
      <br/>
      Each editor is controlled by a set of buttons and check boxes:
      <ul>
        <li>
          <code>Commit</code>
          <br/>
          As the name implies, clicking this buttons commits the
          displayed values to the corresponding option items.
        </li>
        <li>
          <code>Auto Commit</code>
          <br/>
          If this option is checked, changes to displayed values are
          automatically committed to the corresponding option items, without
          having to click
          <code>Commit</code>
          first.
        </li>
        <li>
          <code>Reset</code>
          <br/>
          The standard option item implementations provided by the
          <code>y.option</code> package all support the notion of a backup value.
          The backup value is (usually) the value with which an option item was
          initialized. The only exception is the <code>y.option.EnumOptionItem</code>,
          which allows users to explicitly set its backup value.
          Clicking this button (re-) sets the displayed values to the
          backup values of the corresponding option items.
        </li>
        <li>
          <code>Adopt</code>
          <br/>
          Clicking this button sets the displayed values to the values currently
          stored in the corresponding option items.
        </li>
        <li>
          <code>Auto Adopt</code>
          <br/>
          If this option is checked, the displayed values will be automatically
          updated on changes to the values of the corresponding option items,
          without having to click
          <code>Adopt</code>
          first.
        </li>
      </ul>
    </y:description>
  <y:keywords>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>l10n</y:keyword>
<y:keyword>i18n</y:keyword>
<y:keyword>localization</y:keyword>
<y:keyword>internationalization</y:keyword>
<y:keyword>locale</y:keyword>
<y:keyword>commit</y:keyword>
<y:keyword>adopt</y:keyword>
<y:keyword>auto</y:keyword>
<y:keyword>OptionItem</y:keyword>
<y:keyword>ItemEditor</y:keyword>
<y:keyword>editor</y:keyword>
<y:keyword>GuiFactory</y:keyword>
<y:keyword>OptionGroup</y:keyword>
<y:keyword>useSection</y:keyword>
</y:keywords>
</y:demo>

</y:package>
  </y:package>
</y:content>
